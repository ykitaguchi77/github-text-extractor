<files><file name="README.md">
# Towards Complete and Accurate Iris Segmentation Using Deep Multi-Task Attention Network for Non-Cooperative Iris Recognition

Created by [Caiyong Wang](https://caiyong.wang/) @ Institute of Automation, Chinese Academy of Sciences (**CASIA**)

&lt;img src="new.gif" width="8%" height="8%"&gt; 

&gt; Call for participating in the [**IJCB 2021 Official Competition**](http://ijcb2021.iapr-tc4.org/competitions/) about **NIR Iris Challenge Evaluation in Non-cooperative Environments: Segmentation and Localization (NIR-ISL 2021)**, welcome to visit our competition website: [https://sites.google.com/view/nir-isl2021/home](https://sites.google.com/view/nir-isl2021/home). Competition starting-ending: **February 15 - April 30, 2021**.  [**Registration closed!**]

We propose a high-efficiency deep learning based iris segmentation approach, named **IrisParseNet**. 
The proposed approach first applies a multi-task attention network to simultaneously predict the iris mask, 
pupil mask and iris outer boundary. Then, based on the predicted pupil mask and iris outer boundary, 
parameterized inner and outer iris boundaries are achieved by a simple yet effective post-processing method. 
Overall, the proposed approach is a complete iris segmentation solution, i.e., iris mask and parameterized 
inner and outer iris boundaries are jointly achieved, which facilitates the subsequent iris normalization as well as iris feature extraction and matching. Hence the proposed approach can be used for iris recognition as a general drop-in replacement. To help reproduce our method, we have 
made the **models, manual annotations and evaluation protocol codes** freely available to the community. 

&lt;img src='sample.png' width="420px"&gt;

In the above figure, (a) original iris images from CASIA.v4-distance (top two), MICHE-I (middle three), and UBIRIS.v2 (bottom three) iris databases, 
(b) ground truth iris mask (blue), and inner (green) and outer (red) boundaries of the iris, (c) segmentation results of IrisParseNet (false positive error pixel (green), false negative error
pixel (red), and true positive pixel (blue)), (d) iris outer boundary predicted
by IrisParseNet, (e) pupil mask predicted by IrisParseNet, and (f) localization
results of IrisParseNet after post-processing (inner boundary (green) and outer boundary (red)) are shown from left to right.

## Citation
If you use this model or corresponding codes/datas for your research, please cite our papers.

```
@article{wang2020iris,
  title={Towards Complete and Accurate Iris Segmentation Using Deep Multi-Task Attention Network for Non-Cooperative Iris Recognition}, 
  author={Wang, Caiyong and Muhammad, Jawad and Wang, Yunlong and He, Zhaofeng and Sun, Zhenan},
  journal={IEEE Transactions on Information Forensics and Security}, 
  year={2020},
  volume={15},
  pages={2944-2959},
  publisher={IEEE}
}
```
Anyone is permitted to use, distribute and change this program for any non-commercial usage. However each of such usage and/or publication must include above citation of this paper. For any commercial usage, please send an email to wangcaiyong@bucea.edu.cn or caiyong.wang@cripac.ia.ac.cn. 
 
## Prerequisites
- linux
- Python 2.7 ( python3 is not supported!)
- CPU or NVIDIA GPU + CUDA CuDNN
- [Caffe](http://caffe.berkeleyvision.org/)  
- matlab R2016a 
- [Halcon](https://www.mvtec.com/products/halcon/) 10.0/13.0 or above 

## Getting Started

### Installing Caffe
We have provided the complete Caffe codes. Just install it following the official guide. You can also refer to [our another extended Caffe Version](https://github.com/xiamenwcy/extended-caffe).

- Caffe [[Google Drive]](https://drive.google.com/file/d/181EsUA6p12eoc7GU-zwSG5M4TxIR_pZZ/view) [[Baidu Drive]](https://pan.baidu.com/s/1zttJGXQfH2h3rLc37gQkXA)(zuhv)

&lt;img src="good-news.gif" width="8%" height="8%"&gt; 

&gt; We have built an out-of-the-box Docker Caffe image ([https://www.codewithgpu.com/i/xiamenwcy/IrisParseNet/casia_caffe_tifs](https://www.codewithgpu.com/i/xiamenwcy/IrisParseNet/casia_caffe_tifs)) which is deployed on the [AutoDL](https://www.autodl.com/home) cloud server. You can enjoy it. There are no more worries stopping you from using **IrisParseNet**. :clap::clap:

### Model training and testing

The complete codes for training and testing the model are placed at **Codes/IrisParseNet**, and the post-processing executable program is placed at **Codes/Post-processing**.

We have released the trained models on CASIA.v4-distance (**casia** for short), MICHE-I (**miche** for short), and UBIRIS.v2(**nice** for short). 

- CASIA.v4-distance model [[Google Drive]](https://drive.google.com/file/d/1y1Usfz95avgkAIb3hwvnwCme9pAW8w1A/view?usp=sharing) [[Baidu Drive]](https://pan.baidu.com/s/1N8-3rSiy0OR0g-G82L4MQA)(yavp)
- MICHE-I model [[Google Drive]](https://drive.google.com/file/d/12Qr8W2505APLgxt6aJDtoyT-csWawNq3/view?usp=sharing) [[Baidu Drive]](https://pan.baidu.com/s/1Wbd_5YwyBh4LbxA8cupfOg)(zpi4)
- UBIRIS.v2 model [[Google Drive]](https://drive.google.com/file/d/1WzGxikN4DWn-_Jk7WVLgg4BHEpLpm7Rr/view?usp=sharing) [[Baidu Drive]](https://pan.baidu.com/s/1kGbHBWOt4NzazFaIlhmI6A)(376p)
- VGG_ILSVRC_16_layers.caffemodel  [[Google Drive]](https://drive.google.com/file/d/1biuFHDyD96JLjfd650OGNFL66-WczSDe/view?usp=sharing) [[Baidu Drive]](https://pan.baidu.com/s/1fx5RZMFPIGcDlfS9iFqvEQ)(7ncn)


### Evaluation protocols

The iris segmentation and localization evaluation codes are provided. During realizing the 
evaluation protocols, we've referenced a lot of open source codes. Here, we thank them, especially
[USIT Iris Toolkit v2](http://www.wavelab.at/sources/Rathgeb16a/), [TVM-iris segmentation](https://www4.comp.polyu.edu.hk/~csajaykr/tvmiris.htm), [GlaS Challenge Contest](https://warwick.ac.uk/fac/sci/dcs/research/tia/glascontest/evaluation/).

Please read our paper for detailes. The evaluation codes can be found in **evaluation** folder.

### Annotation codes
we use the interactive development environment (**HDevelop**) provided by the machine vision software, i.e. MVTec Halcon. Before labeling, you need to install Halcon software. Halcon is a paid software, but it allows to try out for free, please refer to the page:
https://www.mvtec.com/products/halcon/now/.

Our halcon based annotation codes can be found in **annotation**. The code can help us to label
iris inner/outer bounadry and output a variety of kinds of annatation results as much as possible.

### Data  

We have provided all training and testing datasets with ground truths to help reproduce our method. Since we 
do not have permission to release the original iris images for MICHE-I and UBIRIS.v2 databases, hence if you want to use the ground truths of these two databases, you can email the owners of both databases to request permission and let us know if given permission. We will provided the password of ground truth files.

 Original iris database: 
- [MICHE-I](http://biplab.unisa.it/MICHE/database/MICHE_BIPLAB_DATABASE/)  Email: biplab@unisa.it.
- [UBIRIS.v2](http://iris.di.ubi.pt/ubiris2.html)  Email: hugomcp@di.ubi.pt.

Ground truth:
- CASIA.v4-distance [[Google Drive]](https://drive.google.com/file/d/1AbYXkYmQ1nfzNNZGr3aD5QQ2wQFxzyLO/view?usp=sharing) [[Baidu Drive]](https://pan.baidu.com/s/1G9kPfq72Iv5TqlPiQd82fA)(kdd6)
- MICHE-I [[Google Drive]](https://drive.google.com/file/d/1V7WUjrY67-LlqKWMoTiMUN8ih-wmbrAq/view?usp=sharing) [[Baidu Drive]](https://pan.baidu.com/s/1xiYXx_c9-NL9S3JL4bNQCA)(84ya)
- UBIRIS.v2 [[Google Drive]](https://drive.google.com/file/d/1WVAUf6lHA6xw1vI9Fz3g_Ovv-_33kvpa/view?usp=sharing) [[Baidu Drive]](https://pan.baidu.com/s/1PRcFKX1wodWFF-7PujITlA)(942d)
  

## Reference 
[1] Zhao, Zijing, and Ajay Kumar. "An Accurate Iris Segmentation Framework Under Relaxed Imaging Constraints Using Total Variation Model." international conference on computer vision (2015): 3828-3836.

[2] Liu, Nianfeng, et al. "Accurate iris segmentation in non-cooperative environments using fully convolutional networks." Biometrics (ICB), 2016 International Conference on. IEEE, 2016.

[3] Hu, Yang, Konstantinos Sirlantzis, and Gareth Howells. "Improving colour iris segmentation using a model selection technique." Pattern Recognition Letters 57 (2015): 24-32.

[4] Proen√ßa H, Alexandre L A. The NICE. I: noisy iris challenge evaluation-part I[C]//2007 First IEEE International Conference on Biometrics: Theory, Applications, and Systems. IEEE, 2007: 1-4.

[5] De Marsico M, Nappi M, Riccio D, et al. Mobile iris challenge evaluation (MICHE)-I, biometric iris dataset and protocols[J]. Pattern Recognition Letters, 2015, 57: 17-23.

## Disclaimer
This package is only provided on "as it is" basis and does not include any warranty of any kind.


## Questions
Please contact wangcaiyong@bucea.edu.cn or caiyong.wang@cripac.ia.ac.cn. 
</file><file name="maskcmpprf.cpp">/*
 * maskcmp.cpp
 *
 * Author: P. Wild (pwild@cosy.sbg.ac.at)
 * Author: H. Hofbauer (hhofbaue@cosy.sbg.ac.at)
 *
 * Compares binary masks resulting in recall precision and f1-measure
 *
 */
#include &lt;cstdio&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;fstream&gt;
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;boost/regex.hpp&gt;
#include &lt;boost/filesystem.hpp&gt;
#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;

using namespace std;
using namespace cv;

/** no globbing in win32 mode **/
int _CRT_glob = 0;
/** Program modes **/
static const int MODE_MAIN = 1, MODE_HELP = 2;

/*
 * Print command line usage for this program
 */
void printUsage() {
	printf("+-----------------------------------------------------------------------------+\n");
	printf("| mskcmp - compares binary masks                                              |\n");
	printf("|                                                                             |\n");
	printf("| MODES                                                                       |\n");
	printf("|                                                                             |\n");
	printf("| (# 1) comparison of binary masks (recall, precision, f measure)             |\n");
	printf("| (# 2) usage                                                                 |\n");
	printf("|                                                                             |\n");
	printf("| ARGUMENTS                                                                   |\n");
	printf("|                                                                             |\n");
	printf("+------+------------+---+---+-------------------------------------------------+\n");
	printf("| Name | Parameters | # | ? | Description                                     |\n");
	printf("+------+------------+---+---+-------------------------------------------------+\n");
	printf("| -i   | infile1    | 1 | N | source/reference iris codes (use * as wildcard, |\n");
	printf("|      | infile2    |   |   | all other files may refer to n-th * with ?n)    |\n");
	printf("| -o   | outfile    | 1 | Y | target text                                     |\n");
	printf("| -q   |            | 1 | Y | quiet mode on (off)                             |\n");
	printf("| -t   |            | 1 | Y | time progress on (off)                          |\n");
	printf("| -h   |            | 2 | N | prints usage                                    |\n");
	printf("+------+------------+---+---+-------------------------------------------------+\n");
	printf("|                                                                             |\n");
	printf("| EXAMPLE USAGE                                                               |\n");
    printf("|                                                                             |\n");
    printf("| -i s1.png s2.png                                                            |\n");
    printf("| -i *.png ?1.png -o compare.txt -q -t                                        |\n");
    printf("|                                                                             |\n");
	printf("| AUTHORS                                                                     |\n");
	printf("|                                                                             |\n");
	printf("| Peter Wild (pwild@cosy.sbg.ac.at)                                           |\n");
	printf("| Heinz Hofbauer (hhofbaue@cosy.sbg.ac.at)                                    |\n");
	printf("|                                                                             |\n");
	printf("| COPYRIGHT                                                                   |\n");
	printf("|                                                                             |\n");
	printf("| (C) 2012 All rights reserved. Do not distribute without written permission. |\n");
	printf("+-----------------------------------------------------------------------------+\n");
}

void cmp(const Mat a, const Mat b, int&amp; tp, int&amp; fp, int&amp; fn, int&amp; tn){
	//unused: unsigned int dist = 0;
	MatConstIterator_&lt;uchar&gt; pa = a.begin&lt;uchar&gt;();
	MatConstIterator_&lt;uchar&gt; pb = b.begin&lt;uchar&gt;();
	MatConstIterator_&lt;uchar&gt; enda = a.end&lt;uchar&gt;();
	for (;pa&lt;enda; pa++, pb++){
        if( *pb &gt; 0 &amp;&amp; *pa &gt; 0){
            tp++;
        }else if( *pb &gt; 0){ //implied pa == 0, else first if
            fn++;
        }else if( *pa &gt; 0){ //implied pb == 0, else first if
            fp++;
        } else {  // both == 0
            tn++;
        }
	}
}

/** ------------------------------- commandline functions ------------------------------- **/

/**
 * Parses a command line
 * This routine should be called for parsing command lines for executables.
 * Note, that all options require '-' as prefix and may contain an arbitrary
 * number of optional arguments.
 *
 * cmd: commandline representation
 * argc: number of parameters
 * argv: string array of argument values
 */
void cmdRead(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, int argc, char *argv[]){
	for (int i=1; i&lt; argc; i++){
		char * argument = argv[i];
		if (strlen(argument) &gt; 1 &amp;&amp; argument[0] == '-' &amp;&amp; (argument[1] &lt; '0' || argument[1] &gt; '9')){
			cmd[argument]; // insert
			char * argument2;
			while (i + 1 &lt; argc &amp;&amp; (strlen(argument2 = argv[i+1]) &lt;= 1 || argument2[0] != '-'  || (argument2[1] &gt;= '0' &amp;&amp; argument2[1] &lt;= '9'))){
				cmd[argument].push_back(argument2);
				i++;
			}
		}
		else {
            cerr&lt;&lt; "Error at arg #"&lt;&lt;i&lt;&lt;" " &lt;&lt;argv[i]&lt;&lt;endl;
			CV_Error(CV_StsBadArg,"Invalid command line format");
		}
	}
}

/**
 * Checks, if each command line option is valid, i.e. exists in the options array
 *
 * cmd: commandline representation
 * validOptions: list of valid options separated by pipe (i.e. |) character
 */
void cmdCheckOpts(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string validOptions){
	vector&lt;string&gt; tokens;
	const string delimiters = "|";
	string::size_type lastPos = validOptions.find_first_not_of(delimiters,0); // skip delimiters at beginning
	string::size_type pos = validOptions.find_first_of(delimiters, lastPos); // find first non-delimiter
	while (string::npos != pos || string::npos != lastPos){
		tokens.push_back(validOptions.substr(lastPos,pos - lastPos)); // add found token to vector
		lastPos = validOptions.find_first_not_of(delimiters,pos); // skip delimiters
		pos = validOptions.find_first_of(delimiters,lastPos); // find next non-delimiter
	}
	sort(tokens.begin(), tokens.end());
	for (map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.begin(); it != cmd.end(); it++){
		if (!binary_search(tokens.begin(),tokens.end(),it-&gt;first)){
			CV_Error(CV_StsBadArg,"Command line parameter '" + it-&gt;first + "' not allowed.");
			tokens.clear();
			return;
		}
	}
	tokens.clear();
}

/*
 * Checks, if a specific required option exists in the command line
 *
 * cmd: commandline representation
 * option: option name
 */
void cmdCheckOptExists(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string option){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	if (it == cmd.end()) CV_Error(CV_StsBadArg,"Command line parameter '" + option + "' is required, but does not exist.");
}

/*
 * Checks, if a specific option has the appropriate number of parameters
 *
 * cmd: commandline representation
 * option: option name
 * size: appropriate number of parameters for the option
 */
void cmdCheckOptSize(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string option, const unsigned int size = 1){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	if (it-&gt;second.size() != size) CV_Error(CV_StsBadArg,"Command line parameter '" + option + "' has unexpected size.");
}

/*
 * Checks, if a specific option has the appropriate number of parameters
 *
 * cmd: commandline representation
 * option: option name
 * min: minimum appropriate number of parameters for the option
 * max: maximum appropriate number of parameters for the option
 */
void cmdCheckOptRange(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, string option, unsigned int min = 0, unsigned int max = 1){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	unsigned int size = it-&gt;second.size();
	if (size &lt; min || size &gt; max) CV_Error(CV_StsBadArg,"Command line parameter '" + option + "' is out of range.");
}

/*
 * Returns the list of parameters for a given option
 *
 * cmd: commandline representation
 * option: name of the option
 */
vector&lt;string&gt; * cmdGetOpt(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string option){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	return (it != cmd.end()) ? &amp;(it-&gt;second) : 0;
}

/*
 * Returns number of parameters in an option
 *
 * cmd: commandline representation
 * option: name of the option
 */
unsigned int cmdSizePars(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string option){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	return (it != cmd.end()) ? it-&gt;second.size() : 0;
}

/*
 * Returns a specific parameter type (int) given an option and parameter index
 *
 * cmd: commandline representation
 * option: name of option
 * param: name of parameter
 */
int cmdGetParInt(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, string option, unsigned int param = 0){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	if (it != cmd.end()) {
		if (param &lt; it-&gt;second.size()) {
			return atoi(it-&gt;second[param].c_str());
		}
	}
	return 0;
}

/*
 * Returns a specific parameter type (float) given an option and parameter index
 *
 * cmd: commandline representation
 * option: name of option
 * param: name of parameter
 */
float cmdGetParFloat(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string option, const unsigned int param = 0){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	if (it != cmd.end()) {
		if (param &lt; it-&gt;second.size()) {
			return atof(it-&gt;second[param].c_str());
		}
	}
	return 0;
}

/*
 * Returns a specific parameter type (string) given an option and parameter index
 *
 * cmd: commandline representation
 * option: name of option
 * param: name of parameter
 */
string cmdGetPar(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string option, const unsigned int param = 0){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	if (it != cmd.end()) {
		if (param &lt; it-&gt;second.size()) {
			return it-&gt;second[param];
		}
	}
	return 0;
}

/** ------------------------------- timing functions ------------------------------- **/

/**
 * Class for handling timing progress information
 */
class Timing{
public:
	/** integer indicating progress with respect tot total **/
	int progress;
	/** total count for progress **/
	int total;

	/*
	 * Default constructor for timing initializing time.
	 * Automatically calls init()
	 *
	 * seconds: update interval in seconds
	 * eraseMode: if true, outputs sends erase characters at each print command
	 */
	Timing(long seconds, bool eraseMode){
		updateInterval = seconds;
		progress = 1;
		total = 100;
		eraseCount=0;
		erase = eraseMode;
		init();
	}

	/*
	 * Destructor
	 */
	~Timing(){}

	/*
	 * Initializes timing variables
	 */
	void init(void){
		start = boost::posix_time::microsec_clock::universal_time();
		lastPrint = start - boost::posix_time::seconds(updateInterval);
	}

	/*
	 * Clears printing (for erase option only)
	 */
	void clear(void){
		string erase(eraseCount,'\r');
		erase.append(eraseCount,' ');
		erase.append(eraseCount,'\r');
		printf("%s",erase.c_str());
		eraseCount = 0;
	}

	/*
	 * Updates current time and returns true, if output should be printed
	 */
	bool update(void){
		current = boost::posix_time::microsec_clock::universal_time();
		return ((current - lastPrint &gt; boost::posix_time::seconds(updateInterval)) || (progress == total));
	}

	/*
	 * Prints timing object to STDOUT
	 */
	void print(void){
		lastPrint = current;
		float percent = 100.f * progress / total;
		boost::posix_time::time_duration passed = (current - start);
		boost::posix_time::time_duration togo = passed * (total - progress) / max(1,progress);
		if (erase) {
			string erase(eraseCount,'\r');
			printf("%s",erase.c_str());
			int newEraseCount = (progress != total) ? printf("Progress ... %3.2f%% (%i/%i Total %i:%02i:%02i.%03i Remaining ca. %i:%02i:%02i.%03i)",percent,progress,total,passed.hours(),passed.minutes(),passed.seconds(),(int)(passed.total_milliseconds()%1000),togo.hours(),togo.minutes(),togo.seconds(),(int)(togo.total_milliseconds() % 1000)) : printf("Progress ... %3.2f%% (%i/%i Total %i:%02i:%02i.%03d)",percent,progress,total,passed.hours(),passed.minutes(),passed.seconds(),(int)(passed.total_milliseconds()%1000));
			if (newEraseCount &lt; eraseCount) {
				string erase(newEraseCount-eraseCount,' ');
				erase.append(newEraseCount-eraseCount,'\r');
				printf("%s",erase.c_str());
			}
			eraseCount = newEraseCount;
		}
		else {
			eraseCount = (progress != total) ? printf("Progress ... %3.2f%% (%i/%i Total %i:%02i:%02i.%03i Remaining ca. %i:%02i:%02i.%03i)\n",percent,progress,total,passed.hours(),passed.minutes(),passed.seconds(),(int)(passed.total_milliseconds()%1000),togo.hours(),togo.minutes(),togo.seconds(),(int)(togo.total_milliseconds() % 1000)) : printf("Progress ... %3.2f%% (%i/%i Total %i:%02i:%02i.%03d)\n",percent,progress,total,passed.hours(),passed.minutes(),passed.seconds(),(int)(passed.total_milliseconds()%1000));
		}
	}
private:
	long updateInterval;
	boost::posix_time::ptime start;
	boost::posix_time::ptime current;
	boost::posix_time::ptime lastPrint;
	int eraseCount;
	bool erase;
};

/** ------------------------------- file pattern matching functions ------------------------------- **/


/*
 * Formats a given string, such that it can be used as a regular expression
 * I.e. escapes special characters and uses * and ? as wildcards
 *
 * pattern: regular expression path pattern
 * pos: substring starting index
 * n: substring size
 *
 * returning: escaped substring
 */
string patternSubstrRegex(string&amp; pattern, size_t pos, size_t n){
	string result;
	for (size_t i=pos, e=pos+n; i &lt; e; i++ ) {
		char c = pattern[i];
		if ( c == '\\' || c == '.' || c == '+' || c == '[' || c == '{' || c == '|' || c == '(' || c == ')' || c == '^' || c == '$' || c == '}' || c == ']') {
			result.append(1,'\\');
			result.append(1,c);
		}
		else if (c == '*'){
			result.append("([^/\\\\]*)");
		}
		else if (c == '?'){
			result.append("([^/\\\\])");
		}
		else {
			result.append(1,c);
		}
	}
	return result;
}

/*
 * Converts a regular expression path pattern into a list of files matching with this pattern by replacing wildcards
 * starting in position pos assuming that all prior wildcards have been resolved yielding intermediate directory path.
 * I.e. this function appends the files in the specified path according to yet unresolved pattern by recursive calling.
 *
 * pattern: regular expression path pattern
 * files: the list to which new files can be applied
 * pos: an index such that positions 0...pos-1 of pattern are already considered/matched yielding path
 * path: the current directory (or empty)
 */
void patternToFiles(string&amp; pattern, vector&lt;string&gt;&amp; files, const size_t&amp; pos, const string&amp; path){
	size_t first_unknown = pattern.find_first_of("*?",pos); // find unknown * in pattern
	if (first_unknown != string::npos){
		size_t last_dirpath = pattern.find_last_of("/\\",first_unknown);
		size_t next_dirpath = pattern.find_first_of("/\\",first_unknown);
		if (next_dirpath != string::npos){
			boost::regex expr((last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? patternSubstrRegex(pattern,last_dirpath+1,next_dirpath-last_dirpath-1) : patternSubstrRegex(pattern,pos,next_dirpath-pos));
			boost::filesystem::directory_iterator end_itr; // default construction yields past-the-end
			try {
				for ( boost::filesystem::directory_iterator itr( ((path.length() &gt; 0) ? path + pattern[pos-1] : (last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? "" : "./") + ((last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? pattern.substr(pos,last_dirpath-pos) : "")); itr != end_itr; ++itr )
				{
					if (boost::filesystem::is_directory(itr-&gt;path())){
						boost::filesystem::path p = itr-&gt;path().filename();
						string s =  p.string();
						if (boost::regex_match(s.c_str(), expr)){
							patternToFiles(pattern,files,(int)(next_dirpath+1),((path.length() &gt; 0) ? path + pattern[pos-1] : "") + ((last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? pattern.substr(pos,last_dirpath-pos) + pattern[last_dirpath] : "") + s);
						}
					}
				}
			}
			catch (boost::filesystem::filesystem_error &amp;e){}
		}
		else {
			boost::regex expr((last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? patternSubstrRegex(pattern,last_dirpath+1,pattern.length()-last_dirpath-1) : patternSubstrRegex(pattern,pos,pattern.length()-pos));
			boost::filesystem::directory_iterator end_itr; // default construction yields past-the-end
			try {
				for ( boost::filesystem::directory_iterator itr(((path.length() &gt; 0) ? path +  pattern[pos-1] : (last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? "" : "./") + ((last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? pattern.substr(pos,last_dirpath-pos) : "")); itr != end_itr; ++itr )
				{
					boost::filesystem::path p = itr-&gt;path().filename();
					string s =  p.string();
					if (boost::regex_match(s.c_str(), expr)){
						files.push_back(((path.length() &gt; 0) ? path + pattern[pos-1] : "") + ((last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? pattern.substr(pos,last_dirpath-pos) + pattern[last_dirpath] : "") + s);
					}
				}
			}
			catch (boost::filesystem::filesystem_error &amp;e){}
		}
	}
	else { // no unknown symbols
		boost::filesystem::path file(((path.length() &gt; 0) ? path + "/" : "") + pattern.substr(pos,pattern.length()-pos));
		if (boost::filesystem::exists(file)){
			files.push_back(file.string());
		}
	}
}

/**
 * Converts a regular expression path pattern into a list of files matching with this pattern
 *
 * pattern: regular expression path pattern
 * files: the list to which new files can be applied
 */
void patternToFiles(string&amp; pattern, vector&lt;string&gt;&amp; files){
	patternToFiles(pattern,files,0,"");
}

/*
 * Renames a given filename corresponding to the actual file pattern using a renaming pattern.
 * Wildcards can be referred to as ?1, ?2, ... in the order they appeared in the file pattern.
 *
 * pattern: regular expression path pattern
 * renamePattern: renaming pattern using ?1, ?2, ... as placeholders for wildcards
 * infile: path of the file (matching with pattern) to be renamed
 * outfile: path of the renamed file
 * par: used parameter (default: '?')
 */
void patternFileRename(string&amp; pattern, const string&amp; renamePattern, const string&amp; infile, string&amp; outfile, const char par = '?'){
	size_t first_unknown = renamePattern.find_first_of(par,0); // find unknown ? in renamePattern
	if (first_unknown != string::npos){
		string formatOut = "";
		for (size_t i=0, e=renamePattern.length(); i &lt; e; i++ ) {
			char c = renamePattern[i];
			if ( c == par &amp;&amp; i+1 &lt; e) {
				c = renamePattern[i+1];
				if (c &gt; '0' &amp;&amp; c &lt;= '9'){
					formatOut.append(1,'$');
					formatOut.append(1,c);
				}
				else {
					formatOut.append(1,par);
					formatOut.append(1,c);
				}
				i++;
			}
			else {
				formatOut.append(1,c);
			}
		}
		boost::regex patternOut(patternSubstrRegex(pattern,0,pattern.length()));
		outfile = boost::regex_replace(infile,patternOut,formatOut,boost::match_default | boost::format_perl);
	} else {
		outfile = renamePattern;
	}
}

/** ------------------------------- Program ------------------------------- **/

/*
 * Main program
 */
int main(int argc, char *argv[])
{
	int mode = MODE_HELP;
	map&lt;string,vector&lt;string&gt; &gt; cmd;
	try {
		cmdRead(cmd,argc,argv);
		if (cmd.size() == 0 || cmdGetOpt(cmd,"-h") != 0) mode = MODE_HELP;
		else mode = MODE_MAIN;
		if (mode == MODE_MAIN){
			// validate command line
			cmdCheckOpts(cmd,"-i|-o|-q|-t");
			cmdCheckOptExists(cmd,"-i");
			cmdCheckOptSize(cmd,"-i",2);
			string infilesSmpl = cmdGetPar(cmd,"-i",0);
			string infilesRef = cmdGetPar(cmd,"-i",1);

			string outfile;
			if (cmdGetOpt(cmd,"-o") != 0){
				cmdCheckOptSize(cmd,"-o",1);
				outfile = cmdGetPar(cmd,"-o");
			}
			bool quiet = false;
			if (cmdGetOpt(cmd,"-q") != 0){
				cmdCheckOptSize(cmd,"-q",0);
				quiet = true;
			}
			bool time = false;
			if (cmdGetOpt(cmd,"-t") != 0){
				cmdCheckOptSize(cmd,"-t",0);
				time = true;
			}
			// starting routine
			Timing timing(1,quiet);
			vector&lt;string&gt; filesSmpl;
			patternToFiles(infilesSmpl,filesSmpl);
			CV_Assert(filesSmpl.size() &gt; 0);
			timing.total = filesSmpl.size();
			ofstream cfile;
			if (!outfile.empty()){
				if (!quiet) printf("Opening result file '%s' ...\n", outfile.c_str());;
				cfile.open(outfile.c_str(),ios::out | ios::trunc);
				if (!(cfile.is_open())) {
					CV_Error(CV_StsError,"Could not open result file '" + outfile + "'");
				}
			}
			double aprecision = 0, arecall = 0, afmeasure = 0;
			for (vector&lt;string&gt;::iterator infileSmpl = filesSmpl.begin(); infileSmpl != filesSmpl.end(); ++infileSmpl){
				string reffile;
				patternFileRename(infilesSmpl,infilesRef,*infileSmpl,reffile);
				if (!quiet) printf("maskcmpprf(%s,%s)", (*infileSmpl).c_str(), (reffile).c_str());
				Mat imgRef = imread(*infileSmpl, CV_LOAD_IMAGE_GRAYSCALE); //UNCHANGED);
				CV_Assert(imgRef.data != 0);
				CV_Assert(imgRef.type() == CV_8UC1);
				Mat img = imread(reffile, CV_LOAD_IMAGE_GRAYSCALE); //UNCHANGED);
				CV_Assert(img.data != 0);
				CV_Assert(img.type() == CV_8UC1);
                int tp = 0, fp=0, fn=0,tn=0;
                cmp(img, imgRef, tp, fp, fn, tn);
				double precision = (tp+fp == 0) ? 0 : ((double) tp) / (double)(tp+fp);
				double recall = (tp+fn == 0) ? 0 : ((double)tp) / (double)(tp+fn);
                double f1 = ( precision + recall ==0) ? 0 : (2*recall*precision/(recall+precision));
                if (!quiet) printf(" = (%6.2f%% recall, %6.2f%% precision, %6.2f%% F_1 measure)\n", 100*recall, 100*precision, 100*f1);
				aprecision += precision; 
				arecall += recall;
                afmeasure += f1;
				if (!outfile.empty() &amp;&amp; cfile.is_open()){
					cfile &lt;&lt; *infileSmpl &lt;&lt; " " &lt;&lt; reffile &lt;&lt; " " &lt;&lt; recall &lt;&lt; " " &lt;&lt; precision &lt;&lt; " " &lt;&lt; f1 &lt;&lt; endl;
				}
				if (time &amp;&amp; timing.update()) timing.print();
			}
			aprecision /= filesSmpl.size();
			arecall /= filesSmpl.size();
            afmeasure /= filesSmpl.size();
			printf("recall = %f%% precision = %f%% f_1 measure=%f%%\n",  100*arecall, 100*aprecision, 100*afmeasure);
			if (time &amp;&amp; quiet) timing.clear();
			if (!outfile.empty() &amp;&amp; cfile.is_open()){
				cfile.close();
			}
    	}
    	else if (mode == MODE_HELP){
			// validate command line
			cmdCheckOpts(cmd,"-h");
			if (cmdGetOpt(cmd,"-h") != 0) cmdCheckOptSize(cmd,"-h",0);
			// starting routine
			printUsage();
    	}
    }
	catch (...){
	   	printf("Exit with errors on call:");
        for( int i =0; i &lt; argc; i++)
            printf(" %s", argv[i]);
        printf("\n");
	   	exit(EXIT_FAILURE);
	}
    return EXIT_SUCCESS;
}
</file><file name="manuseg.cpp">/*
 * manuseg.cpp
 *
 *  Created on: 06.08.2012
 *      Author: Wild
 */

#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;boost/regex.hpp&gt;
#include &lt;boost/filesystem.hpp&gt;
#include &lt;boost/algorithm/string.hpp&gt;
#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;

using namespace std;
using namespace cv;

/** no globbing in win32 mode **/
int _CRT_glob = 0;

/** Program modes **/
static const int MODE_ERROR = 0, MODE_MAIN = 1, MODE_HELP = 2;

/*
 * Print command line usage for this program
 */
void printUsage() {
	cout &lt;&lt; "+-----------------------------------------------------------------------------+" &lt;&lt; endl;
	cout &lt;&lt; "| manuseg - manual iris segmentation                                          |" &lt;&lt; endl;
	cout &lt;&lt; "|                                                                             |" &lt;&lt; endl;
	cout &lt;&lt; "| MODES                                                                       |" &lt;&lt; endl;
	cout &lt;&lt; "|                                                                             |" &lt;&lt; endl;
	cout &lt;&lt; "| (# 1) applies manual segmentation / normalization                           |" &lt;&lt; endl;
	cout &lt;&lt; "| (# 2) usage                                                                 |" &lt;&lt; endl;
	cout &lt;&lt; "|                                                                             |" &lt;&lt; endl;
    cout &lt;&lt; "| ARGUMENTS                                                                   |" &lt;&lt; endl;
    cout &lt;&lt; "|                                                                             |" &lt;&lt; endl;
    cout &lt;&lt; "+------+------------+---+---+-------------------------------------------------+" &lt;&lt; endl;
    cout &lt;&lt; "| Name | Parameters | # | ? | Description                                     |" &lt;&lt; endl;
    cout &lt;&lt; "+------+------------+---+---+-------------------------------------------------+" &lt;&lt; endl;
    cout &lt;&lt; "| -i   | infile     | 1 | N | source image (* = any)                          |" &lt;&lt; endl;
    cout &lt;&lt; "| -c   | innerfile  | 1 | N | target coordinate files (?n = n-th * in infile) |" &lt;&lt; endl;
    cout &lt;&lt; "|      | outerfile  |   |   | with one point (x y) per line, e.g. 12 314      |" &lt;&lt; endl;
    cout &lt;&lt; "|      | upperfile  |   |   | for inner boundary, outer boundary, upper eyelid|" &lt;&lt; endl;
    cout &lt;&lt; "|      | lowerfile  |   |   | lower eyelid                                    |" &lt;&lt; endl;
    cout &lt;&lt; "| -o   | outfile    | 1 | N | output iris texture image                       |" &lt;&lt; endl;
    cout &lt;&lt; "| -m   | maskfile   | 1 | Y | write noise mask (off)                          |" &lt;&lt; endl;
    cout &lt;&lt; "| -sr  | segresfile | 1 | Y | write segmentation result (off)                 |" &lt;&lt; endl;
    cout &lt;&lt; "| -srl | segresfile | 1 | Y | write lidless segmentation result (off)         |" &lt;&lt; endl;
    cout &lt;&lt; "| -roi | roifile    | 1 | Y | write ROI result (off)                          |" &lt;&lt; endl;
    cout &lt;&lt; "| -s   | wdth hght  | 1 | Y | size, i.e. width and height, of output (512x64) |" &lt;&lt; endl;
    cout &lt;&lt; "| -e   |            | 1 | Y | enhance iris texture on (off)                   |" &lt;&lt; endl;
    cout &lt;&lt; "| -q   |            | 1 | Y | quiet mode on (off)                             |" &lt;&lt; endl;
    cout &lt;&lt; "| -t   |            | 1 | Y | time progress on (off)                          |" &lt;&lt; endl;
    cout &lt;&lt; "| -h   |            | 2 | N | prints usage                                    |" &lt;&lt; endl;
    cout &lt;&lt; "+------+------------+---+---+-------------------------------------------------+" &lt;&lt; endl;
    cout &lt;&lt; "|                                                                             |" &lt;&lt; endl;
    cout &lt;&lt; "| AUTHOR                                                                      |" &lt;&lt; endl;
    cout &lt;&lt; "|                                                                             |" &lt;&lt; endl;
    cout &lt;&lt; "| Peter Wild (pwild@cosy.sbg.ac.at)                                           |" &lt;&lt; endl;
    cout &lt;&lt; "|                                                                             |" &lt;&lt; endl;
    cout &lt;&lt; "| COPYRIGHT                                                                   |" &lt;&lt; endl;
    cout &lt;&lt; "|                                                                             |" &lt;&lt; endl;
    cout &lt;&lt; "| (C) 2012 All rights reserved. Do not distribute without written permission. |" &lt;&lt; endl;
    cout &lt;&lt; "+-----------------------------------------------------------------------------+" &lt;&lt; endl;
}

/** ------------------------------- Clahe ------------------------------- **/

/**
 * Calculate a standard uniform upper exclusive lower inclusive 256-bin histogram for range [0,256]
 *
 * src: CV_8UC1 image
 * histogram: CV_32SC1 1 x 256 histogram matrix
 */
void hist2u(const Mat&amp; src, Mat&amp; histogram){
	histogram.setTo(0);
	MatConstIterator_&lt;uchar&gt; s = src.begin&lt;uchar&gt;();
	MatConstIterator_&lt;uchar&gt; e = src.end&lt;uchar&gt;();
	int * p = (int *)histogram.data;
	for (; s!=e; s++){
		p[*s]++;
	}
}

/*
 * Retrieves the (bilinear) interpolated byte from 4 bytes
 *
 * x: distance to left byte
 * y: distance to right byte
 * r: distance to upper byte
 * s: distance to lower byte
 * b1: upper left byte
 * b2: upper right byte
 * b3: lower left byte
 * b4: lower right byte
 */
uchar interp(const double x, const double y, const double r, const double s, const uchar b1, const uchar b2, const uchar b3, const uchar b4) {
  double w1 = (x + y);
  double w2 = x / w1;
  w1 = y / w1;
  double w3 = (r + s);
  double w4 = r / w3;
  w3 = s / w3;
  return saturate_cast&lt;uchar&gt;(w3 * (w1 * b1 + w2 * b2) + w4 * (w1 * b3 + w2 * b4));
}

/*
 * Retrieves the bilinear interpolated byte from 2 bytes
 *
 * x:  distance to left byte
 * y:  distance to right byte
 * b1: left byte
 * b2: right byte
 */
uchar interp(const double x, const double y, const uchar b1, const uchar b2) {
  double w1 = (x + y);
  double w2 = x / w1;
  w1 = y / w1;
  return saturate_cast&lt;uchar&gt;(w1 * b1 + w2 * b2);
}

/*
 * Inplace histogram clipping according to Zuiderveld (counts excess and redistributes excess by adding the average increment)
 *
 * hist: CV_32SC1 1 x 256 histogram matrix
 * clipFactor: between 0 (maximum slope M/N, where M #pixel in window, N #bins) and 1 (maximum slope M)
 * pixelCount: number of pixels in window
 */
void clipHistogram(Mat&amp; hist, const float clipFactor, const int pixelCount) {
	double minSlope = ((double) pixelCount) / 256;
	int clipLimit = std::min(pixelCount, std::max(1, cvCeil(minSlope + clipFactor * (pixelCount - minSlope))));
	int distributeCount = 0;
	MatIterator_&lt;int&gt; p = hist.begin&lt;int&gt;();
	MatIterator_&lt;int&gt; e = hist.end&lt;int&gt;();
	for (; p!=e; p++){
		int binsExcess = *p - clipLimit;
		if (binsExcess &gt; 0) {
			distributeCount += binsExcess;
			*p = clipLimit;
		}
	}
	int avgInc = distributeCount / 256;
	int maxBins = clipLimit - avgInc;
	for (p = hist.begin&lt;int&gt;(); p!=e; p++){
		if (*p &lt;= maxBins) {
			distributeCount -= avgInc;
			*p += avgInc;
		}
		else if (*p &lt; clipLimit) {
			distributeCount -= (clipLimit - *p);
			*p = clipLimit;
		}
	}
	while (distributeCount &gt; 0) {
		for (p = hist.begin&lt;int&gt;(); p!=e &amp;&amp; distributeCount &gt; 0; p++){
			if (*p &lt; clipLimit) {
				(*p)++;
				distributeCount--;
			}
		}
	}
}

/*
 * Contrast-limited adaptive histogram equalization (supports in-place)
 *
 * src: CV_8UC1 image
 * dst: CV_8UC1 image (in-place operation is possible)
 * cellWidth: patch size in x direction (greater or equal to 2)
 * cellHeight: patch size in y direction (greater or equal to 2)
 * clipFactor: histogram clip factor between 0 and 1
 */
void clahe(const Mat&amp; src, Mat&amp; dst, const int cellWidth = 10, const int cellHeight = 10, const float clipFactor = 1.){
	Mat hist(1,256,CV_32SC1);
	Mat roi;
	uchar * sp, * dp;
	int height = src.rows;
	int width = src.cols;
	int gridWidth = width / cellWidth + (width % cellWidth == 0 ? 0 : 1);
	int gridHeight = height / cellHeight + (height % cellHeight == 0 ? 0 : 1);
	int bufSize = (gridWidth + 2)*256;
	int bufOffsetLeft = bufSize - 256;
	int bufOffsetTop = bufSize - gridWidth * 256;
	int bufOffsetTopLeft = bufSize - (gridWidth + 1) * 256;
	Mat buf(1, bufSize, CV_8UC1);
	MatIterator_&lt;uchar&gt; pbuf = buf.begin&lt;uchar&gt;(), ebuf = buf.end&lt;uchar&gt;();
	MatIterator_&lt;int&gt; phist, ehist = hist.end&lt;int&gt;();
	uchar * curr, * topleft, * top, * left;
	int pixelCount, cX, cY, cWidth, cHeight, cellOrigin, cellOffset;
	double sum;
	// process first row, first cell
	cX = 0;
	cY = 0;
	cWidth = min(cellWidth, width);
	cHeight = min(cellHeight, height);
	pixelCount = cWidth*cHeight;
	sum = 0;
	roi = Mat(src,Rect(cX,cY,cWidth,cHeight));
	hist2u(roi,hist);
	if (clipFactor &lt; 1) clipHistogram(hist,clipFactor,pixelCount);
	// equalization
	for(phist = hist.begin&lt;int&gt;(); phist!=ehist; phist++, pbuf++){
		sum += *phist;
		*pbuf = saturate_cast&lt;uchar&gt;(sum * 255 / pixelCount);
	}
	// paint first corner cell
	cWidth = min(cellWidth / 2, cWidth);
	cHeight = min(cellHeight / 2, cHeight);
	cellOrigin = src.step * cY + cX;
	cellOffset = src.step - cWidth;
	sp = (uchar *)(src.data + cellOrigin);
	dp = (uchar *)(dst.data + cellOrigin);
	curr = buf.data;
	for (int b=0; b &lt; cHeight; b++, sp+= cellOffset, dp += cellOffset){
	  for (int a=0; a &lt; cWidth; a++, sp++, dp++){
		*dp = curr[*sp];
	  }
	}
	// process first row, other cells
	for (int x = 1; x &lt; gridWidth; x++) {
		cX = x*cellWidth;
		cWidth = min(cellWidth, width - x*cellWidth);
		cHeight = min(cellHeight, height);
		pixelCount = cWidth*cHeight;
		sum = 0;
		roi.release();
		roi = Mat(src,Rect(cX,cY,cWidth,cHeight));
		hist2u(roi,hist);
		if (clipFactor &lt; 1) clipHistogram(hist,clipFactor,pixelCount);
		// equalization
		for(phist = hist.begin&lt;int&gt;(); phist!=ehist; phist++, pbuf++){
			sum += *phist;
			*pbuf = saturate_cast&lt;uchar&gt;(sum * 255 / pixelCount);
		}
		// paint first row, other cells
		cX += cellWidth/2 - cellWidth;
		cWidth = min(cellWidth, width - x*cellWidth + cellWidth/2);
		cHeight = min(cellHeight / 2, height);
		cellOrigin = src.step * cY + cX;
		cellOffset = src.step - cWidth;
		sp = (uchar *)(src.data + cellOrigin);
		dp = (uchar *)(dst.data + cellOrigin);
		curr = buf.data + (curr - buf.data + 256) % bufSize;
		left = buf.data + (curr - buf.data + bufOffsetLeft) % bufSize;
		for (int b=0; b &lt; cHeight; b++, sp+= cellOffset, dp += cellOffset){
		  for (int a=0; a &lt; cWidth; a++, sp++, dp++){
			  *dp = interp(a,cWidth-a,left[*sp], curr[*sp]);
		  }
		}
	}
	// process (i.e. paint) first row, last cell (only if necessary)
	if (width % cellWidth &gt; cellWidth / 2 || width % cellWidth == 0) {
		cWidth = (width - cellWidth / 2) % cellWidth;
		cHeight = min(cellHeight / 2, height);
		cX = width-cWidth;
		cellOrigin = src.step * cY + cX;
		cellOffset = src.step - cWidth;
		sp = (uchar *)(src.data + cellOrigin);
		dp = (uchar *)(dst.data + cellOrigin);
		for (int b=0; b &lt; cHeight; b++, sp+= cellOffset, dp += cellOffset){
		  for (int a=0; a &lt; cWidth; a++, sp++, dp++){
			*dp = curr[*sp];
		  }
		}
	}
	// process rest of rows
	for (int y = 1; y &lt; gridHeight; y++) {
		// process other rows, first cell
		cX = 0;
		cY = y*cellHeight;
		cWidth = min(cellWidth, width);
		cHeight = min(cellHeight, height - y*cellHeight);
		pixelCount = cWidth*cHeight;
		sum = 0;
		roi.release();
		roi = Mat(src,Rect(cX,cY,cWidth,cHeight));
		hist2u(roi,hist);
		if (clipFactor &lt; 1) clipHistogram(hist,clipFactor,pixelCount);
		// equalization
		if (pbuf == ebuf) pbuf = buf.begin&lt;uchar&gt;();
		for(phist = hist.begin&lt;int&gt;(); phist!=ehist; phist++, pbuf++){
			sum += *phist;
			*pbuf = saturate_cast&lt;uchar&gt;(sum * 255 / pixelCount);
		}
		// paint other rows, first cell
		cY += cellHeight/2 - cellHeight;
		cWidth = min(cellWidth / 2, width);
		cHeight = min(cellHeight, height - y*cellHeight + cellHeight/2);
		cellOrigin = src.step * cY + cX;
		cellOffset = src.step - cWidth;
		sp = (uchar *)(src.data + cellOrigin);
		dp = (uchar *)(dst.data + cellOrigin);
		curr = buf.data + (curr - buf.data + 256) % bufSize;
		top = buf.data + (curr - buf.data + bufOffsetTop) % bufSize;
		for (int b=0; b &lt; cHeight; b++, sp+= cellOffset, dp += cellOffset){
		  for (int a=0; a &lt; cWidth; a++, sp++, dp++){
			  *dp = interp(b,cHeight-b,top[*sp], curr[*sp]);
		  }
		}
		// process other rows, rest of cells
		for (int x = 1; x &lt; gridWidth; x++) {
			cX = x*cellWidth;
			cY = y*cellHeight;
			cWidth = min(cellWidth, width - x*cellWidth);
			cHeight = min(cellHeight, height - y*cellHeight);
			pixelCount = cWidth*cHeight;
			sum = 0;
			roi.release();
			roi = Mat(src,Rect(cX,cY,cWidth,cHeight));
			hist2u(roi,hist);
			if (clipFactor &lt; 1) clipHistogram(hist,clipFactor,pixelCount);
			// equalization
			if (pbuf == ebuf) pbuf = buf.begin&lt;uchar&gt;();
			for(phist = hist.begin&lt;int&gt;(); phist!=ehist; phist++, pbuf++){
				sum += *phist;
				*pbuf = saturate_cast&lt;uchar&gt;(sum * 255 / pixelCount);
			}
			// paint other rows, rest of cells
			cX += cellWidth/2 - cellWidth;
			cY += cellHeight/2 - cellHeight;
			cWidth = min(cellWidth, width - x*cellWidth + cellWidth/2);
			cHeight = min(cellHeight, height - y*cellHeight + cellHeight/2);
			cellOrigin = src.step * cY + cX;
			cellOffset = src.step - cWidth;
			sp = (uchar *)(src.data + cellOrigin);
			dp = (uchar *)(dst.data + cellOrigin);
			curr = buf.data + (curr - buf.data + 256) % bufSize;
			top = buf.data + (curr - buf.data + bufOffsetTop) % bufSize;
			topleft = buf.data + (curr - buf.data + bufOffsetTopLeft) % bufSize;
			left = buf.data + (curr - buf.data + bufOffsetLeft) % bufSize;
			for (int b=0; b &lt; cHeight; b++, sp+= cellOffset, dp += cellOffset){
			  for (int a=0; a &lt; cWidth; a++, sp++, dp++){
				  *dp = interp(a, cWidth-a,b,cHeight-b,topleft[*sp],top[*sp],left[*sp],curr[*sp]);
			  }
			}
		}
		// process (i.e. paint) other rows, last cell (only if necessary)
		if (width % cellWidth &gt; cellWidth / 2 || width % cellWidth == 0) {
			cWidth = (width - cellWidth / 2) % cellWidth;
			cHeight = min(cellHeight, height - y*cellHeight + cellHeight/2);
			cX = width-cWidth;
			cellOrigin = src.step * cY + cX;
			cellOffset = src.step - cWidth;
			sp = (uchar *)(src.data + cellOrigin);
			dp = (uchar *)(dst.data + cellOrigin);
			top = buf.data + (curr - buf.data + bufOffsetTop) % bufSize;
			for (int b=0; b &lt; cHeight; b++, sp+= cellOffset, dp += cellOffset){
			  for (int a=0; a &lt; cWidth; a++, sp++, dp++){
				  *dp = interp(b,cHeight-b,top[*sp], curr[*sp]);
			  }
			}
		}
	}
	// process (i.e. paint) last row (only if necessary)
	if (height % cellHeight &gt; cellHeight / 2 || height % cellHeight == 0) {
		// paint last row, first cell
		cWidth =  min(cellWidth / 2, width);
		cHeight = (height - cellHeight / 2) % cellHeight;
		cX = 0;
		cY = height-cHeight;
		cellOrigin = src.step * cY + cX;
		cellOffset = src.step - cWidth;
		sp = (uchar *)(src.data + cellOrigin);
		dp = (uchar *)(dst.data + cellOrigin);
		curr = buf.data + (curr - buf.data + bufOffsetTop + 256) % bufSize;
		for (int b=0; b &lt; cHeight; b++, sp+= cellOffset, dp += cellOffset){
		  for (int a=0; a &lt; cWidth; a++, sp++, dp++){
			*dp = curr[*sp];
		  }
		}
		// paint last row, other cells
		for (int x = 1; x &lt; gridWidth; x++) {
			cX = (x-1)*cellWidth + cellWidth/2;
			cWidth = min(cellWidth, width - x*cellWidth + cellWidth/2);
			cHeight = (height - cellHeight / 2) % cellHeight;
			cellOrigin = src.step * cY + cX;
			cellOffset = src.step - cWidth;
			sp = (uchar *)(src.data + cellOrigin);
			dp = (uchar *)(dst.data + cellOrigin);
			left = curr;
			curr = buf.data + (curr - buf.data + 256) % bufSize;
			for (int b=0; b &lt; cHeight; b++, sp+= cellOffset, dp += cellOffset){
			  for (int a=0; a &lt; cWidth; a++, sp++, dp++){
				  *dp = interp(a,cWidth-a,left[*sp], curr[*sp]);
			  }
			}
		}
		// paint last row, last cell (only if necessary)
		if (width % cellWidth &gt; cellWidth / 2 || width % cellWidth == 0) {
			cWidth = (width - cellWidth / 2) % cellWidth;
			cHeight = (height - cellHeight / 2) % cellHeight;
			cX = width-cWidth;
			cellOrigin = src.step * cY + cX;
			cellOffset = src.step - cWidth;
			sp = (uchar *)(src.data + cellOrigin);
			dp = (uchar *)(dst.data + cellOrigin);
			for (int b=0; b &lt; cHeight; b++, sp+= cellOffset, dp += cellOffset){
			  for (int a=0; a &lt; cWidth; a++, sp++, dp++){
				  *dp = curr[*sp];
			  }
			}
		}
	}
}


/** ------------------------------- commandline functions ------------------------------- **/

/**
 * Parses a command line
 * This routine should be called for parsing command lines for executables.
 * Note, that all options require '-' as prefix and may contain an arbitrary
 * number of optional arguments.
 *
 * cmd: commandline representation
 * argc: number of parameters
 * argv: string array of argument values
 */
void cmdRead(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, int argc, char *argv[]){
	for (int i=1; i&lt; argc; i++){
		char * argument = argv[i];
		if (strlen(argument) &gt; 1 &amp;&amp; argument[0] == '-' &amp;&amp; (argument[1] &lt; '0' || argument[1] &gt; '9')){
			cmd[argument]; // insert
			char * argument2;
			while (i + 1 &lt; argc &amp;&amp; (strlen(argument2 = argv[i+1]) &lt;= 1 || argument2[0] != '-'  || (argument2[1] &gt;= '0' &amp;&amp; argument2[1] &lt;= '9'))){
				cmd[argument].push_back(argument2);
				i++;
			}
		}
		else {
			CV_Error(CV_StsBadArg,"Invalid command line format");
		}
	}
}

/**
 * Checks, if each command line option is valid, i.e. exists in the options array
 *
 * cmd: commandline representation
 * validOptions: list of valid options separated by pipe (i.e. |) character
 */
void cmdCheckOpts(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string validOptions){
	vector&lt;string&gt; tokens;
	const string delimiters = "|";
	string::size_type lastPos = validOptions.find_first_not_of(delimiters,0); // skip delimiters at beginning
	string::size_type pos = validOptions.find_first_of(delimiters, lastPos); // find first non-delimiter
	while (string::npos != pos || string::npos != lastPos){
		tokens.push_back(validOptions.substr(lastPos,pos - lastPos)); // add found token to vector
		lastPos = validOptions.find_first_not_of(delimiters,pos); // skip delimiters
		pos = validOptions.find_first_of(delimiters,lastPos); // find next non-delimiter
	}
	sort(tokens.begin(), tokens.end());
	for (map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.begin(); it != cmd.end(); it++){
		if (!binary_search(tokens.begin(),tokens.end(),it-&gt;first)){
			CV_Error(CV_StsBadArg,"Command line parameter '" + it-&gt;first + "' not allowed.");
			tokens.clear();
			return;
		}
	}
	tokens.clear();
}

/*
 * Checks, if a specific required option exists in the command line
 *
 * cmd: commandline representation
 * option: option name
 */
void cmdCheckOptExists(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string option){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	if (it == cmd.end()) CV_Error(CV_StsBadArg,"Command line parameter '" + option + "' is required, but does not exist.");
}

/*
 * Checks, if a specific option has the appropriate number of parameters
 *
 * cmd: commandline representation
 * option: option name
 * size: appropriate number of parameters for the option
 */
void cmdCheckOptSize(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string option, const unsigned int size = 1){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	if (it-&gt;second.size() != size) CV_Error(CV_StsBadArg,"Command line parameter '" + option + "' has unexpected size.");
}

/*
 * Checks, if a specific option has the appropriate number of parameters
 *
 * cmd: commandline representation
 * option: option name
 * min: minimum appropriate number of parameters for the option
 * max: maximum appropriate number of parameters for the option
 */
void cmdCheckOptRange(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, string option, unsigned int min = 0, unsigned int max = 1){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	unsigned int size = it-&gt;second.size();
	if (size &lt; min || size &gt; max) CV_Error(CV_StsBadArg,"Command line parameter '" + option + "' is out of range.");
}

/*
 * Returns the list of parameters for a given option
 *
 * cmd: commandline representation
 * option: name of the option
 */
vector&lt;string&gt; * cmdGetOpt(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string option){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	return (it != cmd.end()) ? &amp;(it-&gt;second) : 0;
}

/*
 * Returns number of parameters in an option
 *
 * cmd: commandline representation
 * option: name of the option
 */
unsigned int cmdSizePars(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string option){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	return (it != cmd.end()) ? it-&gt;second.size() : 0;
}

/*
 * Returns a specific parameter type (int) given an option and parameter index
 *
 * cmd: commandline representation
 * option: name of option
 * param: name of parameter
 */
int cmdGetParInt(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, string option, unsigned int param = 0){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	if (it != cmd.end()) {
		if (param &lt; it-&gt;second.size()) {
			return atoi(it-&gt;second[param].c_str());
		}
	}
	return 0;
}

/*
 * Returns a specific parameter type (float) given an option and parameter index
 *
 * cmd: commandline representation
 * option: name of option
 * param: name of parameter
 */
float cmdGetParFloat(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string option, const unsigned int param = 0){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	if (it != cmd.end()) {
		if (param &lt; it-&gt;second.size()) {
			return atof(it-&gt;second[param].c_str());
		}
	}
	return 0;
}

/*
 * Returns a specific parameter type (string) given an option and parameter index
 *
 * cmd: commandline representation
 * option: name of option
 * param: name of parameter
 */
string cmdGetPar(map&lt;string ,vector&lt;string&gt; &gt;&amp; cmd, const string option, const unsigned int param = 0){
	map&lt;string, vector&lt;string&gt; &gt;::iterator it = cmd.find(option);
	if (it != cmd.end()) {
		if (param &lt; it-&gt;second.size()) {
			return it-&gt;second[param];
		}
	}
	return 0;
}

/** ------------------------------- timing functions ------------------------------- **/

/**
 * Class for handling timing progress information
 */
class Timing{
public:
	/** integer indicating progress with respect tot total **/
	int progress;
	/** total count for progress **/
	int total;

	/*
	 * Default constructor for timing initializing time.
	 * Automatically calls init()
	 *
	 * seconds: update interval in seconds
	 * eraseMode: if true, outputs sends erase characters at each print command
	 */
	Timing(long seconds, bool eraseMode){
		updateInterval = seconds;
		progress = 1;
		total = 100;
		eraseCount=0;
		erase = eraseMode;
		init();
	}

	/*
	 * Destructor
	 */
	~Timing(){}

	/*
	 * Initializes timing variables
	 */
	void init(void){
		start = boost::posix_time::microsec_clock::universal_time();
		lastPrint = start - boost::posix_time::seconds(updateInterval);
	}

	/*
	 * Clears printing (for erase option only)
	 */
	void clear(void){
		string erase(eraseCount,'\r');
		erase.append(eraseCount,' ');
		erase.append(eraseCount,'\r');
		printf("%s",erase.c_str());
		eraseCount = 0;
	}

	/*
	 * Updates current time and returns true, if output should be printed
	 */
	bool update(void){
		current = boost::posix_time::microsec_clock::universal_time();
		return ((current - lastPrint &gt; boost::posix_time::seconds(updateInterval)) || (progress == total));
	}

	/*
	 * Prints timing object to STDOUT
	 */
	void print(void){
		lastPrint = current;
		float percent = 100.f * progress / total;
		boost::posix_time::time_duration passed = (current - start);
		boost::posix_time::time_duration togo = passed * (total - progress) / max(1,progress);
		if (erase) {
			string erase(eraseCount,'\r');
			printf("%s",erase.c_str());
			int newEraseCount = (progress != total) ? printf("Progress ... %3.2f%% (%i/%i Total %i:%02i:%02i.%03i Remaining ca. %i:%02i:%02i.%03i)",percent,progress,total,passed.hours(),passed.minutes(),passed.seconds(),(int)(passed.total_milliseconds()%1000),togo.hours(),togo.minutes(),togo.seconds(),(int)(togo.total_milliseconds() % 1000)) : printf("Progress ... %3.2f%% (%i/%i Total %i:%02i:%02i.%03d)",percent,progress,total,passed.hours(),passed.minutes(),passed.seconds(),(int)(passed.total_milliseconds()%1000));
			if (newEraseCount &lt; eraseCount) {
				string erase(newEraseCount-eraseCount,' ');
				erase.append(newEraseCount-eraseCount,'\r');
				printf("%s",erase.c_str());
			}
			eraseCount = newEraseCount;
		}
		else {
			eraseCount = (progress != total) ? printf("Progress ... %3.2f%% (%i/%i Total %i:%02i:%02i.%03i Remaining ca. %i:%02i:%02i.%03i)\n",percent,progress,total,passed.hours(),passed.minutes(),passed.seconds(),(int)(passed.total_milliseconds()%1000),togo.hours(),togo.minutes(),togo.seconds(),(int)(togo.total_milliseconds() % 1000)) : printf("Progress ... %3.2f%% (%i/%i Total %i:%02i:%02i.%03d)\n",percent,progress,total,passed.hours(),passed.minutes(),passed.seconds(),(int)(passed.total_milliseconds()%1000));
		}
	}
private:
	long updateInterval;
	boost::posix_time::ptime start;
	boost::posix_time::ptime current;
	boost::posix_time::ptime lastPrint;
	int eraseCount;
	bool erase;
};

/** ------------------------------- file pattern matching functions ------------------------------- **/


/*
 * Formats a given string, such that it can be used as a regular expression
 * I.e. escapes special characters and uses * and ? as wildcards
 *
 * pattern: regular expression path pattern
 * pos: substring starting index
 * n: substring size
 *
 * returning: escaped substring
 */
string patternSubstrRegex(string&amp; pattern, size_t pos, size_t n){
	string result;
	for (size_t i=pos, e=pos+n; i &lt; e; i++ ) {
		char c = pattern[i];
		if ( c == '\\' || c == '.' || c == '+' || c == '[' || c == '{' || c == '|' || c == '(' || c == ')' || c == '^' || c == '$' || c == '}' || c == ']') {
			result.append(1,'\\');
			result.append(1,c);
		}
		else if (c == '*'){
			result.append("([^/\\\\]*)");
		}
		else if (c == '?'){
			result.append("([^/\\\\])");
		}
		else {
			result.append(1,c);
		}
	}
	return result;
}

/*
 * Converts a regular expression path pattern into a list of files matching with this pattern by replacing wildcards
 * starting in position pos assuming that all prior wildcards have been resolved yielding intermediate directory path.
 * I.e. this function appends the files in the specified path according to yet unresolved pattern by recursive calling.
 *
 * pattern: regular expression path pattern
 * files: the list to which new files can be applied
 * pos: an index such that positions 0...pos-1 of pattern are already considered/matched yielding path
 * path: the current directory (or empty)
 */
void patternToFiles(string&amp; pattern, vector&lt;string&gt;&amp; files, const size_t&amp; pos, const string&amp; path){
	size_t first_unknown = pattern.find_first_of("*?",pos); // find unknown * in pattern
	if (first_unknown != string::npos){
		size_t last_dirpath = pattern.find_last_of("/\\",first_unknown);
		size_t next_dirpath = pattern.find_first_of("/\\",first_unknown);
		if (next_dirpath != string::npos){
			boost::regex expr((last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? patternSubstrRegex(pattern,last_dirpath+1,next_dirpath-last_dirpath-1) : patternSubstrRegex(pattern,pos,next_dirpath-pos));
			boost::filesystem::directory_iterator end_itr; // default construction yields past-the-end
			try {
				for ( boost::filesystem::directory_iterator itr( ((path.length() &gt; 0) ? path + pattern[pos-1] : (last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? "" : "./") + ((last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? pattern.substr(pos,last_dirpath-pos) : "")); itr != end_itr; ++itr )
				{
					if (boost::filesystem::is_directory(itr-&gt;path())){
						boost::filesystem::path p = itr-&gt;path().filename();
						string s =  p.string();
						if (boost::regex_match(s.c_str(), expr)){
							patternToFiles(pattern,files,(int)(next_dirpath+1),((path.length() &gt; 0) ? path + pattern[pos-1] : "") + ((last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? pattern.substr(pos,last_dirpath-pos) + pattern[last_dirpath] : "") + s);
						}
					}
				}
			}
			catch (boost::filesystem::filesystem_error &amp;e){}
		}
		else {
			boost::regex expr((last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? patternSubstrRegex(pattern,last_dirpath+1,pattern.length()-last_dirpath-1) : patternSubstrRegex(pattern,pos,pattern.length()-pos));
			boost::filesystem::directory_iterator end_itr; // default construction yields past-the-end
			try {
				for ( boost::filesystem::directory_iterator itr(((path.length() &gt; 0) ? path +  pattern[pos-1] : (last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? "" : "./") + ((last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? pattern.substr(pos,last_dirpath-pos) : "")); itr != end_itr; ++itr )
				{
					boost::filesystem::path p = itr-&gt;path().filename();
					string s =  p.string();
					if (boost::regex_match(s.c_str(), expr)){
						files.push_back(((path.length() &gt; 0) ? path + pattern[pos-1] : "") + ((last_dirpath != string::npos &amp;&amp; last_dirpath &gt; pos) ? pattern.substr(pos,last_dirpath-pos) + pattern[last_dirpath] : "") + s);
					}
				}
			}
			catch (boost::filesystem::filesystem_error &amp;e){}
		}
	}
	else { // no unknown symbols
		boost::filesystem::path file(((path.length() &gt; 0) ? path + "/" : "") + pattern.substr(pos,pattern.length()-pos));
		if (boost::filesystem::exists(file)){
			files.push_back(file.string());
		}
	}
}

/**
 * Converts a regular expression path pattern into a list of files matching with this pattern
 *
 * pattern: regular expression path pattern
 * files: the list to which new files can be applied
 */
void patternToFiles(string&amp; pattern, vector&lt;string&gt;&amp; files){
	patternToFiles(pattern,files,0,"");
}

/*
 * Renames a given filename corresponding to the actual file pattern using a renaming pattern.
 * Wildcards can be referred to as ?1, ?2, ... in the order they appeared in the file pattern.
 *
 * pattern: regular expression path pattern
 * renamePattern: renaming pattern using ?1, ?2, ... as placeholders for wildcards
 * infile: path of the file (matching with pattern) to be renamed
 * outfile: path of the renamed file
 * par: used parameter (default: '?')
 */
void patternFileRename(string&amp; pattern, const string&amp; renamePattern, const string&amp; infile, string&amp; outfile, const char par = '?'){
	size_t first_unknown = renamePattern.find_first_of(par,0); // find unknown ? in renamePattern
	if (first_unknown != string::npos){
		string formatOut = "";
		for (size_t i=0, e=renamePattern.length(); i &lt; e; i++ ) {
			char c = renamePattern[i];
			if ( c == par &amp;&amp; i+1 &lt; e) {
				c = renamePattern[i+1];
				if (c &gt; '0' &amp;&amp; c &lt;= '9'){
					formatOut.append(1,'$');
					formatOut.append(1,c);
				}
				else {
					formatOut.append(1,par);
					formatOut.append(1,c);
				}
				i++;
			}
			else {
				formatOut.append(1,c);
			}
		}
		boost::regex patternOut(patternSubstrRegex(pattern,0,pattern.length()));
		outfile = boost::regex_replace(infile,patternOut,formatOut,boost::match_default | boost::format_perl);
	} else {
		outfile = renamePattern;
	}
}

void polyfit(const Mat&amp; src_x, const Mat&amp; src_y, Mat&amp; dst, int order)
{
	    CV_Assert((src_x.rows&gt;0)&amp;&amp;(src_y.rows&gt;0)&amp;&amp;(src_x.cols==1)&amp;&amp;(src_y.cols==1)
	            &amp;&amp;(dst.cols==1)&amp;&amp;(dst.rows==(order+1))&amp;&amp;(order&gt;=1));
	    Mat X;
	    X = Mat::zeros(src_x.rows, order+1,CV_32FC1);
	    Mat copy;
	    for(int i = 0; i &lt;=order;i++)
	    {
	        copy = src_x.clone();
	        pow(copy,i,copy);
	        Mat M1 = X.col(i);
	        copy.col(0).copyTo(M1);
	    }
	    Mat X_t, X_inv;
	    transpose(X,X_t);
	    Mat temp = X_t*X;
	    Mat temp2;
	    invert (temp,temp2);
	    Mat temp3 = temp2*X_t;
	    Mat W = temp3*src_y;
	    W.copyTo(dst);
}

// samples a polynom
void polysample(const Mat&amp; poly, vector&lt;Point2f&gt;&amp; curve, const double xStart, const double xEnd, const int samples){
	CV_Assert(poly.cols == 1 &amp;&amp; poly.rows == 3 &amp;&amp; poly.type() == CV_32FC1);
	float * polyData = (float*) poly.data;
	for (int i=0; i&lt;samples; i++){
		double x = xStart + (i*(xEnd-xStart))/(samples-1);
		curve.push_back(Point2f(x,polyData[0]+polyData[1]*x+polyData[2]*x*x));
	}
}



void loadPoints(string filename, vector&lt;Point2f&gt;&amp; points) {
	ifstream coordfile;
	coordfile.open(filename.c_str(),ios::in);
	//CV_Assert(coordfile.is_open());
	while (!coordfile.eof()){
		string line;
		vector&lt;string&gt; coords;
		getline (coordfile,line);
		if (!line.empty()){
			boost::split(coords,line,boost::is_any_of("\t "));
			CV_Assert(coords.size() == 2);
			points.push_back(Point(atof(coords[0].c_str()),atof(coords[1].c_str())));
		}
	}
	coordfile.close();
}

void loadPolyPoints(string filename, vector&lt;Point2f&gt;&amp; points, int width){
	vector&lt;Point2f&gt; points2;
	loadPoints(filename,points2);
	if (points2.size() &gt;= 3) {
		Mat res(3,1,CV_32FC1);
		Mat x(points2.size(),1,CV_32FC1);
		Mat y(points2.size(),1,CV_32FC1);
		float *xd = (float *) x.data;
		float *yd = (float *) y.data;
		for (vector&lt;Point2f&gt;::iterator it = points2.begin(); it != points2.end(); ++it,++xd,++yd){
			*xd = (*it).x;
			*yd = (*it).y;
		}
		polyfit(x,y,res,2);
		polysample(res, points, 0, width-1, width);
	}
}

/**
 * Samples an ellipse in cartesian coordinates
 * cart: CV_32FC2 1 x size cartesian coordinates
 * ellipse: ellipse to be sampled
 */
void ellipse2Cart(Mat&amp; cart, const RotatedRect&amp; ellipse) {
	CV_Assert(cart.type() == CV_32FC2);
	float centerX = ellipse.center.x;
	float centerY = ellipse.center.y;
	float ellA = ellipse.size.width/2;
	float ellB = ellipse.size.height/2;
	double alpha = (ellipse.angle)*M_PI/180; // inclination angle of the ellipse
	if (alpha &gt; M_PI) alpha -= M_PI; // normalize alpha to [0,M_PI]
	const double cosAlpha = cos(alpha);
	const double sinAlpha = sin(alpha);
	float * d = (float *)cart.data;
	int width = cart.cols;
	const float thetaoffset = 2 * M_PI / cart.cols;
	float theta = 0;
	for (int x=0; x&lt;width; x++, d++, theta += thetaoffset){
		float beta = (alpha &lt;= theta) ? theta - alpha : 2 * M_PI + theta - alpha; // angle of polar ray in ellipse coords (alpha + beta = theta)
		float s = ellA * cos(beta), t = ellB * sin(beta);
		*d = centerX + cosAlpha * s - sinAlpha * t; // x coordiante
		d++;
		*d = centerY + sinAlpha * s + cosAlpha * t; // y coordinate
	}
}

/** ------------------------------- Rubbersheet transform ------------------------------- **/

/*
 * interpolation mode for rubbersheet repeating the last pixel for a given angle if no values are available
 * (otherwise behaves like INTER_LINEAR)
 */
static const int INTER_LINEAR_REPEAT = 82;

/*
 * Calculates the mapped (polar) image of source using two transformation contours.
 *
 * src: CV_8U (cartesian) source image (possibly multi-channel)
 * dst:	CV_8U (polar) destination image (possibly multi-channel, 2 times the col size of inner)
 * inner: CV_32FC2 inner cartesian coordinates
 * outer: CV_32FC2 outer cartesian coordinates
 * interpolation: interpolation mode (INTER_NEAREST, INTER_LINEAR or INTER_LINEAR_REPEAT)
 * fill: fill value for pixels out of the image
 */
void rubbersheet(const Mat&amp; src, Mat&amp; dst, const Mat&amp; inner, const Mat&amp; outer, const int interpolation = INTER_LINEAR, const uchar fill = 0) {
	int nChannels = src.channels();
	int dstheight = dst.rows;
	int dstwidth = dst.cols;
	int srcheight = src.rows;
	int srcwidth = src.cols;
	uchar * pdst = dst.data;
	int dstoffset = dst.step - dstwidth * nChannels;
	int srcstep = src.step;
	float roffset = 1.f / dstheight;
	float r = 0;
	if (interpolation == INTER_NEAREST){
		for (int y=0; y &lt; dstheight; y++, pdst+= dstoffset, r+=roffset){
			float * pinner = (float *) inner.data;
			float * pouter = (float *) outer.data;
			for (int x=0; x &lt; dstwidth; x++, pinner++, pouter++){
				float a = *pinner + r * (*pouter - *pinner);
				pinner++; pouter++;
				float b =  *pinner + r * (*pouter - *pinner);
				int coordX = cvRound(a);
				int coordY = cvRound(b);
				if (coordX &lt; 0 || coordY &lt; 0 || coordX &gt;= srcwidth || coordY &gt;= srcheight){
					for (int i=0; i&lt; nChannels; i++,pdst++){
						*pdst = fill;
					}
				}
				else {
					uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
					for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
						*pdst = *psrc;
					}
				}
			}
		}
	}
	else if (interpolation == INTER_LINEAR){
		for (int y=0; y &lt; dstheight; y++, pdst+= dstoffset, r+= roffset){
			float * pinner = (float *) inner.data;
			float * pouter = (float *) outer.data;
			for (int x=0; x &lt; dstwidth; x++, pinner++, pouter++){
				float a = *pinner + r * (*pouter - *pinner);
				pinner++; pouter++;
				float b =  *pinner + r * (*pouter - *pinner);
				int coordX = cvFloor(a);
				int coordY = cvFloor(b);
				if (coordX &gt;= 0){
					if (coordY &gt;= 0){
						if (coordX &lt; srcwidth-1){
							if (coordY &lt; srcheight-1){
								float dx = a-coordX;
								float dy = b-coordY;
								uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
								for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
									*pdst = saturate_cast&lt;uchar&gt;((1-dy)*((1-dx)*((float)(*psrc)) + dx*(float)(psrc[nChannels]))+ dy*((1-dx)*((float)(psrc[srcstep])) + dx*(float)(psrc[nChannels+srcstep])));
								}
							}
							else if (coordY == srcheight-1){ // bottom out
								float dx = a-coordX;
								float dy = b-coordY;
								uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
								for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
									*pdst = saturate_cast&lt;uchar&gt;((1-dy)*((1-dx)*((float)(*psrc)) + dx*(float)(psrc[nChannels])) + dy * ((float) fill));
								}
							}
							else {
								for (int i=0; i&lt; nChannels; i++,pdst++){
									*pdst = fill;
								}
							}
						}
						else if (coordX == srcwidth-1){
							if (coordY &lt; srcheight-1){// right out
								float dx = a-coordX;
								float dy = b-coordY;
								uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
								for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
									*pdst = saturate_cast&lt;uchar&gt;((1-dx)*((1-dy)*((float)(*psrc))+ dy*((float)(psrc[srcstep]))) + dx * ((float) fill));
								}
							}
							else if (coordY == srcheight-1){ // bottom right out
								float dx = a-coordX;
								float dy = b-coordY;
								uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
								for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
									*pdst = saturate_cast&lt;uchar&gt;((1-dy)*((1-dx)*((float)(*psrc)) + dx * ((float)fill)) + dy * ((float) fill));
								}
							}
							else {
								for (int i=0; i&lt; nChannels; i++,pdst++){
									*pdst = fill;
								}
							}
						}
						else {
							for (int i=0; i&lt; nChannels; i++,pdst++){
								*pdst = fill;
							}
						}
					}
					else if (coordY == -1){
						if (coordX &lt; srcwidth-1){// top out
								float dx = a-coordX;
								float dy = b-coordY;
								uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
								for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
									*pdst = saturate_cast&lt;uchar&gt;((dy)*((1-dx)*((float)(psrc[srcstep])) + dx*(float)(psrc[nChannels+srcstep])) + (1-dy) * ((float) fill));
								}
						}
						else if (coordX == srcwidth-1){// top right out
								float dx = a-coordX;
								float dy = b-coordY;
								uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
								for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
									*pdst = saturate_cast&lt;uchar&gt;((dy)*((1-dx)*((float)(psrc[srcstep])) + dx * ((float)fill)) + (1-dy) * ((float) fill));
								}
						}
						else {
							for (int i=0; i&lt; nChannels; i++,pdst++){
								*pdst = fill;
							}
						}
					}
					else {
						for (int i=0; i&lt; nChannels; i++,pdst++){
							*pdst = fill;
						}
					}
				}
				else if (coordX == -1){
					if (coordY &gt;= 0){
						if (coordY &lt; srcheight-1){// left out
							float dx = a-coordX;
							float dy = b-coordY;
							uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
							for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
								*pdst = saturate_cast&lt;uchar&gt;(dx*((1-dy)*(float)(psrc[nChannels]) + dy*(float)(psrc[nChannels+srcstep])) + (1-dx) * ((float) fill));
							}
						}
						else if (coordY == srcheight-1){ // left bottom out
							float dx = a-coordX;
							float dy = b-coordY;
							uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
							for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
								*pdst = saturate_cast&lt;uchar&gt;((1-dy)*((dx)*((float)(psrc[nChannels])) + (1-dx) * ((float) fill)) + dy * ((float) fill));
							}
						}
						else {
							for (int i=0; i&lt; nChannels; i++,pdst++){
								*pdst = fill;
							}
						}
					}
					else if (coordY == -1){ // left top out
						float dx = a-coordX;
						float dy = b-coordY;
						uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
						for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
							*pdst = saturate_cast&lt;uchar&gt;((dy)*((dx)*((float)(psrc[nChannels+srcstep])) + (1-dx) * ((float) fill)) + (1-dy) * ((float) fill));
						}
					}
					else {
						for (int i=0; i&lt; nChannels; i++,pdst++){
							*pdst = fill;
						}
					}
				}
				else {
					for (int i=0; i&lt; nChannels; i++,pdst++){
						*pdst = fill;
					}
				}
			}
		}
	}
	else { // INTER_LINEAR_REPEAT (repeats last pixel value)
		uchar * firstLine = pdst + dst.step;
		int step = dst.step;
		for (int y=0; y &lt; dstheight; y++, pdst+= dstoffset, r+= roffset){
			float * pinner = (float *) inner.data;
			float * pouter = (float *) outer.data;
			for (int x=0; x &lt; dstwidth; x++, pinner++, pouter++){
				float a = *pinner + r * (*pouter - *pinner);
				pinner++; pouter++;
				float b =  *pinner + r * (*pouter - *pinner);
				int coordX = cvFloor(a);
				int coordY = cvFloor(b);
				if (coordX &gt;= 0){
					if (coordY &gt;= 0){
						if (coordX &lt; srcwidth-1){
							if (coordY &lt; srcheight-1){
								float dx = a-coordX;
								float dy = b-coordY;
								uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
								for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
									*pdst = saturate_cast&lt;uchar&gt;((1-dy)*((1-dx)*((float)(*psrc)) + dx*(float)(psrc[nChannels]))+ dy*((1-dx)*((float)(psrc[srcstep])) + dx*(float)(psrc[nChannels+srcstep])));
								}
							}
							else if (coordY == srcheight-1){ // bottom out
								float dx = a-coordX;
								uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
								for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
									*pdst = saturate_cast&lt;uchar&gt;(((1-dx)*((float)(*psrc)) + dx*(float)(psrc[nChannels])));
								}
							}
							else if (pdst &gt;= firstLine){
								for (int i=0; i&lt; nChannels; i++,pdst++){
									*pdst = *(pdst - step); // one row above
								}
							}
							else {
								for (int i=0; i&lt; nChannels; i++,pdst++){
									*pdst = fill;
								}
							}
						}
						else if (coordX == srcwidth-1){
							if (coordY &lt; srcheight-1){// right out
								float dy = b-coordY;
								uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
								for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
									*pdst = saturate_cast&lt;uchar&gt;(((1-dy)*((float)(*psrc))+ dy*((float)(psrc[srcstep]))));
								}
							}
							else if (coordY == srcheight-1){ // bottom right out
								uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
								for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
									*pdst = *psrc;
								}
							}
							else if (pdst &gt;= firstLine){
								for (int i=0; i&lt; nChannels; i++,pdst++){
									*pdst = *(pdst - step); // one row above
								}
							}
							else {
								for (int i=0; i&lt; nChannels; i++,pdst++){
									*pdst = fill;
								}
							}
						}
						else {
							for (int i=0; i&lt; nChannels; i++,pdst++){
								*pdst = *(pdst - step); // one row above
							}
						}
					}
					else if (coordY == -1){
						if (coordX &lt; srcwidth-1){// top out
								float dx = a-coordX;
								uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
								for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
									*pdst = saturate_cast&lt;uchar&gt;(((1-dx)*((float)(psrc[srcstep])) + dx*(float)(psrc[nChannels+srcstep])));
								}
						}
						else if (coordX == srcwidth-1){// top right out
								uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
								for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
									*pdst = psrc[srcstep];
								}
						}
						else if (pdst &gt;= firstLine){
							for (int i=0; i&lt; nChannels; i++,pdst++){
								*pdst = *(pdst - step); // one row above
							}
						}
						else {
							for (int i=0; i&lt; nChannels; i++,pdst++){
								*pdst = fill;
							}
						}
					}
					else if (pdst &gt;= firstLine){
						for (int i=0; i&lt; nChannels; i++,pdst++){
							*pdst = *(pdst - step); // one row above
						}
					}
					else {
						for (int i=0; i&lt; nChannels; i++,pdst++){
							*pdst = fill;
						}
					}
				}
				else if (coordX == -1){
					if (coordY &gt;= 0){
						if (coordY &lt; srcheight-1){// left out
							float dy = b-coordY;
							uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
							for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
								*pdst = saturate_cast&lt;uchar&gt;(((1-dy)*(float)(psrc[nChannels]) + dy*(float)(psrc[nChannels+srcstep])));
							}
						}
						else if (coordY == srcheight-1){ // bottom left out
							uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
							for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
								*pdst = psrc[nChannels];
							}
						}
						else if (pdst &gt;= firstLine){
							for (int i=0; i&lt; nChannels; i++,pdst++){
								*pdst = *(pdst - step); // one row above
							}
						}
						else {
							for (int i=0; i&lt; nChannels; i++,pdst++){
								*pdst = fill;
							}
						}
					}
					else if (coordY == -1){ // top left out
						uchar * psrc = (uchar*) (src.data+coordY*srcstep+coordX*nChannels);
						for (int i=0; i&lt; nChannels; i++,pdst++,psrc++){
							*pdst = psrc[nChannels+srcstep];
						}
					}
					else if (pdst &gt;= firstLine){
						for (int i=0; i&lt; nChannels; i++,pdst++){
							*pdst = *(pdst - step); // one row above
						}
					}
					else {
						for (int i=0; i&lt; nChannels; i++,pdst++){
							*pdst = fill;
						}
					}
				}
				else if (pdst &gt;= firstLine){
					for (int i=0; i&lt; nChannels; i++,pdst++){
						*pdst = *(pdst - step); // one row above
					}
				}
				else {
					for (int i=0; i&lt; nChannels; i++,pdst++){
						*pdst = fill;
					}
				}
			}
		}
	}
}


void reverse(vector&lt;Point2f&gt;&amp; curve,vector&lt;Point2f&gt;&amp; reversed){
	for (vector&lt;Point2f&gt;::iterator it = curve.end(); it != curve.begin(); --it){
		reversed.push_back(*(it-1));
	}
}

/*
 * Main program
 */
int main(int argc, char *argv[])
{
	int mode = MODE_HELP;
	map&lt;string,vector&lt;string&gt; &gt; cmd;
	try {
		cmdRead(cmd,argc,argv);
		if (cmd.size() == 0 || cmdGetOpt(cmd,"-h") != 0) mode = MODE_HELP;
    	else mode = MODE_MAIN;
    	if (mode == MODE_MAIN) {
			// validate command line
			cmdCheckOpts(cmd,"-i|-c|-o|-m|-s|-sr|-srl|-roi|-e|-q|-t");
			cmdCheckOptExists(cmd,"-i");
			cmdCheckOptSize(cmd,"-i",1);
			string infiles = cmdGetPar(cmd,"-i",0);
			cmdCheckOptExists(cmd,"-c");
			cmdCheckOptSize(cmd,"-c",4);
			string innerfiles = cmdGetPar(cmd,"-c",0);
			string outerfiles = cmdGetPar(cmd,"-c",1);
			string upperfiles = cmdGetPar(cmd,"-c",2);
			string lowerfiles = cmdGetPar(cmd,"-c",3);
			cmdCheckOptExists(cmd,"-o");
			cmdCheckOptSize(cmd,"-o",1);
			string outfiles = cmdGetPar(cmd,"-o");
			string maskfiles;
			if (cmdGetOpt(cmd,"-m") != 0){
				cmdCheckOptSize(cmd,"-m",1);
				maskfiles = cmdGetPar(cmd,"-m");
			}
			string segresfiles;
			if (cmdGetOpt(cmd,"-sr") != 0){
				cmdCheckOptSize(cmd,"-sr",1);
				segresfiles = cmdGetPar(cmd,"-sr");
			}
			string segreslfiles;
			if (cmdGetOpt(cmd,"-srl") != 0){
				cmdCheckOptSize(cmd,"-srl",1);
				segreslfiles = cmdGetPar(cmd,"-srl");
			}
			string roifiles;
			if (cmdGetOpt(cmd,"-roi") != 0){
				cmdCheckOptSize(cmd,"-roi",1);
				roifiles = cmdGetPar(cmd,"-roi");
			}
			int outWidth = 512, outHeight = 64;
			if (cmdGetOpt(cmd,"-s") != 0){
				cmdCheckOptSize(cmd,"-s",2);
				outWidth = cmdGetParInt(cmd,"-s",0);
				outHeight = cmdGetParInt(cmd,"-s",1);
			}
			bool enhance = false;
			if (cmdGetOpt(cmd,"-e") != 0){
				cmdCheckOptSize(cmd,"-e",0);
				enhance = true;
			}
			bool q = false;
			if (cmdGetOpt(cmd,"-q") != 0){
				cmdCheckOptSize(cmd,"-q",0);
				q = true;
			}
			bool t = false;
			if (cmdGetOpt(cmd,"-t") != 0){
				cmdCheckOptSize(cmd,"-t",0);
				t = true;
			}
			// starting routine
			Timing timing(1,q);
			vector&lt;string&gt; files;
		    patternToFiles(infiles,files);
			CV_Assert(files.size() &gt; 0);
			timing.total = files.size();
			for (vector&lt;string&gt;::iterator infile = files.begin(); infile != files.end(); ++infile, timing.progress++){
				if (!q) cout &lt;&lt; "Loading image '" &lt;&lt; *infile &lt;&lt; "' ..."&lt;&lt; endl;
				Mat img = imread(*infile, CV_LOAD_IMAGE_GRAYSCALE);
				CV_Assert(img.data != 0);
				CV_Assert(img.channels() == 1 || img.channels() == 3);
				CV_Assert(img.depth() == CV_8U);
				string innerfile, outerfile, upperfile, lowerfile;
				patternFileRename(infiles,innerfiles,*infile,innerfile);
				patternFileRename(infiles,outerfiles,*infile,outerfile);
				patternFileRename(infiles,upperfiles,*infile,upperfile);
				patternFileRename(infiles,lowerfiles,*infile,lowerfile);
				vector&lt;Point2f&gt; innerPoints, outerPoints, upperPoints, lowerPoints, rlowerPoints;
				if (!q) cout &lt;&lt; "done" &lt;&lt; endl &lt;&lt; "Loading coordinates '" &lt;&lt; innerfile &lt;&lt; "' ... ";
				loadPoints(innerfile,innerPoints);
				if (!q) cout &lt;&lt; innerPoints.size() &lt;&lt; " Points found " &lt;&lt; endl;
				if (!q) cout &lt;&lt; "Loading coordinates '" &lt;&lt; outerfile &lt;&lt; "' ... ";
				loadPoints(outerfile,outerPoints);
				if (!q) cout &lt;&lt; outerPoints.size() &lt;&lt; " Points found " &lt;&lt; endl;
				if (!q) cout &lt;&lt; "Loading coordinates '" &lt;&lt; upperfile &lt;&lt; "' ... ";
				loadPolyPoints(upperfile,upperPoints,img.cols);
				if (!q) cout &lt;&lt; upperPoints.size() &lt;&lt; " Points found " &lt;&lt; endl;
				upperPoints.push_back(Point2f(img.cols+1,0.f));
				upperPoints.push_back(Point2f(0.f,0.f));
				if (!q) cout &lt;&lt; "Loading coordinates '" &lt;&lt; lowerfile &lt;&lt; "' ... ";
				loadPolyPoints(lowerfile,lowerPoints,img.cols);
				if (!q) cout &lt;&lt; lowerPoints.size() &lt;&lt; " Points found " &lt;&lt; endl;
				reverse(lowerPoints,rlowerPoints);
				rlowerPoints.push_back(Point2f(0.f,img.rows));
				rlowerPoints.push_back(Point2f(img.cols,img.rows));
				Mat bw(img.rows,img.cols,CV_8UC1);
				Mat innerBoundary(1,outWidth,CV_32FC2);
				Mat outerBoundary(1,outWidth,CV_32FC2);
				bw.setTo(Scalar(0,0,0));
				RotatedRect inner = fitEllipse(innerPoints);
				ellipse2Cart(innerBoundary,inner);
				RotatedRect outer = fitEllipse(outerPoints);
				ellipse2Cart(outerBoundary,outer);
				Mat out (outHeight,outWidth,CV_8UC1);
				rubbersheet(img, out, innerBoundary, outerBoundary, INTER_LINEAR);
				if (enhance){
					int width = img.cols;
					int height = img.rows;
					if (!q) printf("Enhancing texture ...\n");
					clahe(out,out,width/8,height/2);
				}
				if (!maskfiles.empty() || !segresfiles.empty()|| !segreslfiles.empty()){
					ellipse(bw,outer,Scalar(255,255,255),-1);
					ellipse(bw,inner,Scalar(0,0,0),-1);
					int nupper = (int)upperPoints.size();
					Point upper_points[1][nupper];
					for (int i=0; i&lt;nupper; i++){
						upper_points[0][i] = upperPoints[i];
					}

					const Point* upPoints[1] = { upper_points[0] };

					int nlower = (int)rlowerPoints.size();
					Point rlower_points[1][nupper];
					for (int i=0; i&lt;nlower; i++){
						rlower_points[0][i] = rlowerPoints[i];
					}
					const Point* downPoints[1] = { rlower_points[0] };
					if (!segreslfiles.empty()){
						string segreslfile;
						patternFileRename(infiles,segreslfiles,*infile,segreslfile);
						if (!q) cout &lt;&lt; "Storing image '" &lt;&lt; segreslfile &lt;&lt; "' ..."&lt;&lt; endl;
						if (!imwrite(segreslfile,bw)) CV_Error(CV_StsError,"Could not save image '" + segreslfile + "'");
						if (!q) cout &lt;&lt; "done" &lt;&lt; endl;
					}
					fillPoly(bw,upPoints,&amp;nupper,1,Scalar(0,0,0));
					fillPoly(bw,downPoints,&amp;nlower,1,Scalar(0,0,0));
					if (!segresfiles.empty()){
						string segresfile;
						patternFileRename(infiles,segresfiles,*infile,segresfile);
						if (!q) cout &lt;&lt; "Storing image '" &lt;&lt; segresfile &lt;&lt; "' ..."&lt;&lt; endl;
						if (!imwrite(segresfile,bw)) CV_Error(CV_StsError,"Could not save image '" + segresfile + "'");
						if (!q) cout &lt;&lt; "done" &lt;&lt; endl;
					}

					if (!maskfiles.empty()){
						Mat outNoise (outHeight,outWidth,CV_8UC1);
						rubbersheet(bw, outNoise, innerBoundary, outerBoundary, INTER_NEAREST);
						string maskfile;
						patternFileRename(infiles,maskfiles,*infile,maskfile);
						if (!q) cout &lt;&lt; "Storing image '" &lt;&lt; maskfile &lt;&lt; "' ..."&lt;&lt; endl;

						if (!imwrite(maskfile,outNoise)) CV_Error(CV_StsError,"Could not save image '" + maskfile + "'");
						if (!q) cout &lt;&lt; "done" &lt;&lt; endl;
					}
				}
				if (!roifiles.empty()){
					Mat roi(img.rows,img.cols,CV_8UC1);
					roi.setTo(230);
					ellipse(roi,outer,Scalar(255,255,255),-1);
					ellipse(roi,inner,Scalar(0,0,0),-1);
					int nupper = (int)upperPoints.size();
					Point upper_points[1][nupper];
					for (int i=0; i&lt;nupper; i++){
						upper_points[0][i] = upperPoints[i];
					}

					const Point* upPoints[1] = { upper_points[0] };

					int nlower = (int)rlowerPoints.size();
					Point rlower_points[1][nupper];
					for (int i=0; i&lt;nlower; i++){
						rlower_points[0][i] = rlowerPoints[i];
					}
					const Point* downPoints[1] = { rlower_points[0] };

					fillPoly(roi,upPoints,&amp;nupper,1,Scalar(128));
					fillPoly(roi,downPoints,&amp;nlower,1,Scalar(128));
					MatConstIterator_&lt;uchar&gt; isrc = img.begin&lt;uchar&gt;();
					MatIterator_&lt;uchar&gt; idst = roi.begin&lt;uchar&gt;();
					MatConstIterator_&lt;uchar&gt; iend = img.end&lt;uchar&gt;();
					for(;isrc!=iend;isrc++,idst++){
						if (*idst == 255) *idst = *isrc;
					}
					string roifile;
					patternFileRename(infiles,roifiles,*infile,roifile);
					if (!q) cout &lt;&lt; "Storing image '" &lt;&lt; roifile &lt;&lt; "' ..."&lt;&lt; endl;
					if (!imwrite(roifile,roi)) CV_Error(CV_StsError,"Could not save image '" + roifile + "'");
					if (!q) cout &lt;&lt; "done" &lt;&lt; endl;

				}
				/*
				if (ellpoints.size() &gt;= 5) {
					if (!q) cout &lt;&lt; "done" &lt;&lt; endl &lt;&lt; "Fitting ellipse ..."&lt;&lt; endl;
					RotatedRect ell = fitEllipse(ellpoints);
					ellipse(img,ell,Scalar(lb,lg,lr),thickness);
				}
				if (!q) cout &lt;&lt; "done" &lt;&lt; endl &lt;&lt; "Drawing points ..."&lt;&lt; endl;
				if (ellpoints.size() &gt; 0) {
					for(vector&lt;Point2f&gt;::iterator p = ellpoints.begin(); p &lt; ellpoints.end(); ++p){
						line(img,Point((*p).x,(*p).y-2*thickness),Point((*p).x,(*p).y+2*thickness),Scalar(pb,pg,pr),thickness);
						line(img,Point((*p).x-2*thickness,(*p).y),Point((*p).x+2*thickness,(*p).y),Scalar(pb,pg,pr),thickness);
					}
				}
				*/
				string outfile;
				patternFileRename(infiles,outfiles,*infile,outfile);
				if (!q) cout &lt;&lt; "done" &lt;&lt; endl &lt;&lt; "Storing image '" &lt;&lt; outfile &lt;&lt; "' ..."&lt;&lt; endl;
				if (!imwrite(outfile,out)) CV_Error(CV_StsError,"Could not save image '" + outfile + "'");
				if (!q) cout &lt;&lt; "done" &lt;&lt; endl;
				if (t &amp;&amp; timing.update()) timing.print();
			}
			if (t &amp;&amp; q) timing.clear();
    	}
    	else if (mode == MODE_HELP){
			// validate command line
			cmdCheckOpts(cmd,"-h");
			if (cmdGetOpt(cmd,"-h") != 0) cmdCheckOptSize(cmd,"-h",0);
			// starting routine
			printUsage();
    	}
    }
	catch (...){
		cerr &lt;&lt; "Exit with errors." &lt;&lt; endl;
		exit(EXIT_FAILURE);
	}
    return EXIT_SUCCESS;
}
</file><file name="test_all_single_scale_general_nir.py"># -*- coding: utf-8 -*-
"""
Created on Wed Jan 24 15:46:35 2018

@author: wcy
"""
import numpy as np
import scipy.misc
import cv2
import scipy.io
import os, sys, argparse
import time
from os.path import join, splitext, split, isfile
parser = argparse.ArgumentParser(description='Forward all testing images.')
parser.add_argument('--model', type=str, default='../snapshot/casia/iris_iter_30000.caffemodel') 
parser.add_argument('--net', type=str, default='../model/casia/deploy_bottom_up.pt')
parser.add_argument('--gpu', type=int, default=1)
args = parser.parse_args()
caffe_root = './caffe/'
sys.path.insert(0, caffe_root + 'python')
import caffe
EPSILON = 1e-8

def forward(data):
  assert data.ndim == 3
  data -= np.array((104.00698793,116.66876762,122.67891434))
  data = data.transpose((2, 0, 1))
  net.blobs['data'].reshape(1, *data.shape)
  net.blobs['data'].data[...] = data
  return net.forward()
  
def load_image(path, width=0,height=0, pad=True):
    """
    Load image from a given path and pad it on the sides, so that eash side is divisible by 32 (newtwork requirement)
    
    if pad = True:
        returns image as numpy.array, tuple with padding in pixels as(x_min_pad, y_min_pad, x_max_pad, y_max_pad)
    else:
        returns image as numpy.array
    """
    img = cv2.imread(str(path)).astype(np.float32)
    if img.ndim == 2:
       img = img[:, :, np.newaxis]
       img = np.repeat(img, 3, 2)
    
    if not pad:
        return img
    
    ori_height, ori_width, _ = img.shape
    
    if width==0:   #ÈÄâÊã©Ë∑ùÁ¶ªÊ†áÂáÜÊúÄËøëÁöÑÂ§ßÂ∞è
        k = int(np.ceil((ori_width+31)/32.0))
        width = 32*k-31
    if height==0:
        k = int(np.ceil((ori_height+31)/32.0))
        height = 32*k-31
    
    pad_height = max(height - ori_height, 0);
    pad_width  = max(width - ori_width, 0);
    
    print("width:{},height:{}".format(width,  height ))
    
    img = cv2.copyMakeBorder(img, 0, pad_height, 0, pad_width, cv2.BORDER_REFLECT_101)

    return img, (pad_height, pad_width)  
  
def crop_image(img, pads):
    """
    img: numpy array of the shape (height, width)
    pads: (pad_height, pad_width) 
    
    @return padded image
    """
    (pad_height, pad_width)  = pads
    height, width = img.shape[-2:] 
    
    if len(img.shape) == 2:
        return img[0:height - pad_height, 0:width - pad_width]
    elif len(img.shape)==3:
        return img[:,0:height - pad_height, 0:width - pad_width]
    else:
        return img
    
def create_labels(map,threshold=0.5): #h*w
    labels=(map&gt;=threshold).astype(np.float32)
    return labels


assert isfile(args.model) and isfile(args.net), 'file not exists'
USE_GPU = True
if USE_GPU:
   caffe.set_device(args.gpu)
   caffe.set_mode_gpu()
else:
   caffe.set_mode_cpu()

net = caffe.Net(args.net, args.model, caffe.TEST)
test_dir = '/data3/caiyong.wang/data/IrisLocSeg/CASIA-Iris-M1/image/' # test images directory
save_mask_dir = join('./test/casia_m1/', splitext(split(args.model)[1])[0],'mask/') # directory to save results
if not os.path.exists(save_mask_dir):  
    os.makedirs(save_mask_dir)
save_pupil_dir = join('./test/casia_m1/', splitext(split(args.model)[1])[0],'pupil/') # directory to save results
if not os.path.exists(save_pupil_dir):
    os.makedirs(save_pupil_dir) 
save_iris_dir = join('./test/casia_m1/', splitext(split(args.model)[1])[0],'iris/') # directory to save results
if not os.path.exists(save_iris_dir):
    os.makedirs(save_iris_dir)              
    
imgs = [i for i in os.listdir(test_dir) if '.JPEG' in i]
nimgs = len(imgs)
print "totally "+str(nimgs)+"images"
start = time.time()
for i in range(nimgs):
  img_path = join(test_dir, imgs[i])
  img, pads = load_image(img_path,0,0, pad=True)
  fn, ext = splitext(imgs[i])
	
  forward(img)
  
  
  mask_out1 = crop_image(net.blobs['Sigmoid_fuse_mask'].data[0][0,:,:], pads)
  
  scipy.misc.imsave(join(save_mask_dir, fn+'.png'),mask_out1)
  
  iris_result = crop_image(net.blobs['Sigmoid_fuse_iris'].data[0][0,:,:], pads)
  
  scipy.misc.imsave(join(save_iris_dir, fn+'.png'),iris_result)
  
  pupil_result = crop_image(net.blobs["Sigmoid_fuse_pupil"].data[0][0,:,:], pads)
  
  scipy.misc.imsave(join(save_pupil_dir, fn+'.png'),pupil_result)
  
  
  print "Saving to '" + join(save_mask_dir, imgs[i][0:-4]) + "', Processing %d of %d..."%(i + 1, nimgs) 
end = time.time()
avg_time = (end-start)/nimgs
print("average time is %f seconds"%avg_time)
</file><file name="test_all_single_scale_general_vis.py"># -*- coding: utf-8 -*-
"""
Created on Wed Jan 24 15:46:35 2018

@author: wcy
"""
import numpy as np
import scipy.misc
import cv2
import scipy.io
import os, sys, argparse
import time
from os.path import join, splitext, split, isfile
parser = argparse.ArgumentParser(description='Forward all testing images.')
parser.add_argument('--model', type=str, default='../snapshot/nice/iris_iter_30000.caffemodel') 
parser.add_argument('--net', type=str, default='../model/nice/deploy_bottom_up.pt')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()
caffe_root = './caffe/'
sys.path.insert(0, caffe_root + 'python')
import caffe
EPSILON = 1e-8

def forward(data):
  assert data.ndim == 3
  data -= np.array((104.00698793,116.66876762,122.67891434))
  data = data.transpose((2, 0, 1))
  net.blobs['data'].reshape(1, *data.shape)
  net.blobs['data'].data[...] = data
  return net.forward()
  
def load_image(path, width=0,height=0, pad=True):
    """
    Load image from a given path and pad it on the sides, so that eash side is divisible by 32 (newtwork requirement)
    
    if pad = True:
        returns image as numpy.array, tuple with padding in pixels as(x_min_pad, y_min_pad, x_max_pad, y_max_pad)
    else:
        returns image as numpy.array
    """
    img = cv2.imread(str(path)).astype(np.float32)
    if img.ndim == 2:
       img = img[:, :, np.newaxis]
       img = np.repeat(img, 3, 2)
    
    if not pad:
        return img
    
    ori_height, ori_width, _ = img.shape
    
    if width==0:   #ÈÄâÊã©Ë∑ùÁ¶ªÊ†áÂáÜÊúÄËøëÁöÑÂ§ßÂ∞è
        k = int(np.ceil((ori_width+31)/32.0))
        width = 32*k-31
    if height==0:
        k = int(np.ceil((ori_height+31)/32.0))
        height = 32*k-31
    
    pad_height = max(height - ori_height, 0);
    pad_width  = max(width - ori_width, 0);
    
    print("width:{},height:{}".format(width,  height ))
    
    img = cv2.copyMakeBorder(img, 0, pad_height, 0, pad_width, cv2.BORDER_REFLECT_101)

    return img, (pad_height, pad_width)  
  
def crop_image(img, pads):
    """
    img: numpy array of the shape (height, width)
    pads: (pad_height, pad_width) 
    
    @return padded image
    """
    (pad_height, pad_width)  = pads
    height, width = img.shape[-2:] 
    
    if len(img.shape) == 2:
        return img[0:height - pad_height, 0:width - pad_width]
    elif len(img.shape)==3:
        return img[:,0:height - pad_height, 0:width - pad_width]
    else:
        return img
    
def create_labels(map,threshold=0.5): #h*w
    labels=(map&gt;=threshold).astype(np.float32)
    return labels


assert isfile(args.model) and isfile(args.net), 'file not exists'
USE_GPU = True
if USE_GPU:
   caffe.set_device(args.gpu)
   caffe.set_mode_gpu()
else:
   caffe.set_mode_cpu()

net = caffe.Net(args.net, args.model, caffe.TEST)
test_dir = '/data3/caiyong.wang/data/IrisLocSeg/cross/img/' # test images directory
save_mask_dir = join('./test/cross/', splitext(split(args.model)[1])[0],'mask/') # directory to save results
if not os.path.exists(save_mask_dir):  
    os.makedirs(save_mask_dir)
save_pupil_dir = join('./test/cross/', splitext(split(args.model)[1])[0],'pupil/') # directory to save results
if not os.path.exists(save_pupil_dir):
    os.makedirs(save_pupil_dir) 
save_iris_dir = join('./test/cross/', splitext(split(args.model)[1])[0],'iris/') # directory to save results
if not os.path.exists(save_iris_dir):
    os.makedirs(save_iris_dir)              
    
imgs = [i for i in os.listdir(test_dir) if '.bmp' in i]
nimgs = len(imgs)
print "totally "+str(nimgs)+"images"
start = time.time()
for i in range(nimgs):
  img_path = join(test_dir, imgs[i])
  img, pads = load_image(img_path,0,0, pad=True)
  fn, ext = splitext(imgs[i])
	
  forward(img)
  
  
  mask_out1 = create_labels(net.blobs['Sigmoid_fuse_mask'].data[0][0,:,:])
  mask_out1 = crop_image(mask_out1, pads)
  

  scipy.misc.imsave(join(save_mask_dir, fn+'.png'),mask_out1)
  
  iris_result = crop_image(net.blobs['Sigmoid_fuse_iris'].data[0][0,:,:], pads)
  
  scipy.misc.imsave(join(save_iris_dir, fn+'.png'),iris_result)
  
  pupil_result = crop_image(net.blobs["Sigmoid_fuse_pupil"].data[0][0,:,:], pads)
  
  scipy.misc.imsave(join(save_pupil_dir, fn+'.png'),pupil_result)
  
  
  print "Saving to '" + join(save_mask_dir, imgs[i][0:-4]) + "', Processing %d of %d..."%(i + 1, nimgs) 
end = time.time()
avg_time = (end-start)/nimgs
print("average time is %f seconds"%avg_time)
</file><file name="test_all_single_scale_miche.py"># -*- coding: utf-8 -*-
"""
Created on Wed Jan 24 15:46:35 2018

@author: wcy
"""
import numpy as np
import scipy.misc
import cv2
import scipy.io
import os, sys, argparse
import time
from os.path import join, splitext, split, isfile
parser = argparse.ArgumentParser(description='Forward all testing images.')
parser.add_argument('--model', type=str, default='../snapshot/miche/iris_iter_30000.caffemodel') 
parser.add_argument('--net', type=str, default='../model/miche/deploy_bottom_up.pt')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()
caffe_root = './caffe/'
sys.path.insert(0, caffe_root + 'python')
import caffe
EPSILON = 1e-8

def forward(data):
  assert data.ndim == 3
  data -= np.array((104.00698793,116.66876762,122.67891434))
  data = data.transpose((2, 0, 1))
  net.blobs['data'].reshape(1, *data.shape)
  net.blobs['data'].data[...] = data
  return net.forward()
  
def load_image(path, width=0,height=0, pad=True):
    """
    Load image from a given path and pad it on the sides, so that eash side is divisible by 32 (newtwork requirement)
    
    if pad = True:
        returns image as numpy.array, tuple with padding in pixels as(x_min_pad, y_min_pad, x_max_pad, y_max_pad)
    else:
        returns image as numpy.array
    """
    img = cv2.imread(str(path)).astype(np.float32)
    if img.ndim == 2:
       img = img[:, :, np.newaxis]
       img = np.repeat(img, 3, 2)
    
    if not pad:
        return img
    
    ori_height, ori_width, _ = img.shape
    
    if width==0:   #ÈÄâÊã©Ë∑ùÁ¶ªÊ†áÂáÜÊúÄËøëÁöÑÂ§ßÂ∞è
        k = int(np.ceil((ori_width+31)/32.0))
        width = 32*k-31
    if height==0:
        k = int(np.ceil((ori_height+31)/32.0))
        height = 32*k-31
    
    pad_height = max(height - ori_height, 0);
    pad_width  = max(width - ori_width, 0);
    
    print("width:{},height:{}".format(width,  height ))
    
    img = cv2.copyMakeBorder(img, 0, pad_height, 0, pad_width, cv2.BORDER_REFLECT_101)

    return img, (pad_height, pad_width)  
  
def crop_image(img, pads):
    """
    img: numpy array of the shape (height, width)
    pads: (pad_height, pad_width) 
    
    @return padded image
    """
    (pad_height, pad_width)  = pads
    height, width = img.shape[-2:] 
    
    if len(img.shape) == 2:
        return img[0:height - pad_height, 0:width - pad_width]
    elif len(img.shape)==3:
        return img[:,0:height - pad_height, 0:width - pad_width]
    else:
        return img
    
def create_labels(map,threshold=0.5): #h*w
    labels=(map&gt;=threshold).astype(np.float32)
    return labels


assert isfile(args.model) and isfile(args.net), 'file not exists'
USE_GPU = True
if USE_GPU:
   caffe.set_device(args.gpu)
   caffe.set_mode_gpu()
else:
   caffe.set_mode_cpu()

net = caffe.Net(args.net, args.model, caffe.TEST)
test_dir = '/data3/caiyong.wang/data/IrisLocSeg/MICHE/test/image/' # test images directory
save_mask_dir = join('./test/miche/', splitext(split(args.model)[1])[0],'mask/') # directory to save results
if not os.path.exists(save_mask_dir):  
    os.makedirs(save_mask_dir)
save_pupil_dir = join('./test/miche/', splitext(split(args.model)[1])[0],'pupil/') # directory to save results
if not os.path.exists(save_pupil_dir):
    os.makedirs(save_pupil_dir) 
save_iris_dir = join('./test/miche/', splitext(split(args.model)[1])[0],'iris/') # directory to save results
if not os.path.exists(save_iris_dir):
    os.makedirs(save_iris_dir)              
    
imgs = [i for i in os.listdir(test_dir) if '.JPEG' in i]
nimgs = len(imgs)
print "totally "+str(nimgs)+"images"
start = time.time()
for i in range(nimgs):
  img_path = join(test_dir, imgs[i])
  img, pads = load_image(img_path,0,0, pad=True)
  fn, ext = splitext(imgs[i])
	
  forward(img)
  
  
  # mask_out1 = create_labels(net.blobs['Sigmoid_fuse_mask'].data[0][0,:,:])
  # mask_out1 = crop_image(mask_out1, pads)
  mask_out1 = crop_image(net.blobs['Sigmoid_fuse_mask'].data[0][0,:,:], pads)
  

  scipy.misc.imsave(join(save_mask_dir, fn+'.png'),mask_out1)
  
  iris_result = crop_image(net.blobs['Sigmoid_fuse_iris'].data[0][0,:,:], pads)
  
  scipy.misc.imsave(join(save_iris_dir, fn+'.png'),iris_result)
  
  pupil_result = crop_image(net.blobs["Sigmoid_fuse_pupil"].data[0][0,:,:], pads)
  
  scipy.misc.imsave(join(save_pupil_dir, fn+'.png'),pupil_result)
  
  
  print "Saving to '" + join(save_mask_dir, imgs[i][0:-4]) + "', Processing %d of %d..."%(i + 1, nimgs) 
end = time.time()
avg_time = (end-start)/nimgs
print("average time is %f seconds"%avg_time)
</file><file name="test_all_single_scale_nice.py"># -*- coding: utf-8 -*-
"""
Created on Wed Jan 24 15:46:35 2018

@author: wcy
"""
import numpy as np
import scipy.misc
import cv2
import scipy.io
import os, sys, argparse
import time
from os.path import join, splitext, split, isfile
parser = argparse.ArgumentParser(description='Forward all testing images.')
parser.add_argument('--model', type=str, default='../snapshot/nice/iris_iter_30000.caffemodel') 
parser.add_argument('--net', type=str, default='../model/nice/deploy_bottom_up.pt')
parser.add_argument('--gpu', type=int, default=3)
args = parser.parse_args()
caffe_root = './caffe/'
sys.path.insert(0, caffe_root + 'python')
import caffe
EPSILON = 1e-8

def forward(data):
  assert data.ndim == 3
  data -= np.array((104.00698793,116.66876762,122.67891434))
  data = data.transpose((2, 0, 1))
  net.blobs['data'].reshape(1, *data.shape)
  net.blobs['data'].data[...] = data
  return net.forward()
  
def load_image(path, width=0,height=0, pad=True):
    """
    Load image from a given path and pad it on the sides, so that eash side is divisible by 32 (newtwork requirement)
    
    if pad = True:
        returns image as numpy.array, tuple with padding in pixels as(x_min_pad, y_min_pad, x_max_pad, y_max_pad)
    else:
        returns image as numpy.array
    """
    img = cv2.imread(str(path)).astype(np.float32)
    if img.ndim == 2:
       img = img[:, :, np.newaxis]
       img = np.repeat(img, 3, 2)
    
    if not pad:
        return img
    
    ori_height, ori_width, _ = img.shape
    
    if width==0:   #ÈÄâÊã©Ë∑ùÁ¶ªÊ†áÂáÜÊúÄËøëÁöÑÂ§ßÂ∞è
        k = int(np.ceil((ori_width+31)/32.0))
        width = 32*k-31
    if height==0:
        k = int(np.ceil((ori_height+31)/32.0))
        height = 32*k-31
    
    pad_height = max(height - ori_height, 0);
    pad_width  = max(width - ori_width, 0);
    
    print("width:{},height:{}".format(width,  height ))
    
    img = cv2.copyMakeBorder(img, 0, pad_height, 0, pad_width, cv2.BORDER_REFLECT_101)

    return img, (pad_height, pad_width)  
  
def crop_image(img, pads):
    """
    img: numpy array of the shape (height, width)
    pads: (pad_height, pad_width) 
    
    @return padded image
    """
    (pad_height, pad_width)  = pads
    height, width = img.shape[-2:] 
    
    if len(img.shape) == 2:
        return img[0:height - pad_height, 0:width - pad_width]
    elif len(img.shape)==3:
        return img[:,0:height - pad_height, 0:width - pad_width]
    else:
        return img
    
def create_labels(map,threshold=0.5): #h*w
    labels=(map&gt;=threshold).astype(np.float32)
    return labels


assert isfile(args.model) and isfile(args.net), 'file not exists'
USE_GPU = True
if USE_GPU:
   caffe.set_device(args.gpu)
   caffe.set_mode_gpu()
else:
   caffe.set_mode_cpu()

net = caffe.Net(args.net, args.model, caffe.TEST)
test_dir = '/data3/caiyong.wang/data/IrisLocSeg/NICE/test/image/' # test images directory
save_mask_dir = join('./test/nice/', splitext(split(args.model)[1])[0],'mask/') # directory to save results
if not os.path.exists(save_mask_dir):  
    os.makedirs(save_mask_dir)
save_pupil_dir = join('./test/nice/', splitext(split(args.model)[1])[0],'pupil/') # directory to save results
if not os.path.exists(save_pupil_dir):
    os.makedirs(save_pupil_dir) 
save_iris_dir = join('./test/nice/', splitext(split(args.model)[1])[0],'iris/') # directory to save results
if not os.path.exists(save_iris_dir):
    os.makedirs(save_iris_dir)              
    
imgs = [i for i in os.listdir(test_dir) if '.JPEG' in i]
nimgs = len(imgs)
print "totally "+str(nimgs)+"images"
start = time.time()
for i in range(nimgs):
  img_path = join(test_dir, imgs[i])
  img, pads = load_image(img_path,0,0, pad=True)
  fn, ext = splitext(imgs[i])
	
  forward(img)
  
  mask_out1 = crop_image(net.blobs['Sigmoid_fuse_mask'].data[0][0,:,:], pads)

  scipy.misc.imsave(join(save_mask_dir, fn+'.png'),mask_out1)
  
  iris_result = crop_image(net.blobs['Sigmoid_fuse_iris'].data[0][0,:,:], pads)
  
  scipy.misc.imsave(join(save_iris_dir, fn+'.png'),iris_result)
  
  pupil_result = crop_image(net.blobs["Sigmoid_fuse_pupil"].data[0][0,:,:], pads)
  
  scipy.misc.imsave(join(save_pupil_dir, fn+'.png'),pupil_result)
  
  
  print "Saving to '" + join(save_mask_dir, imgs[i][0:-4]) + "', Processing %d of %d..."%(i + 1, nimgs) 
end = time.time()
avg_time = (end-start)/nimgs
print("average time is %f seconds"%avg_time)
</file><file name="test_all_single_scale_casia.py"># -*- coding: utf-8 -*-
"""
Created on Wed Jan 24 15:46:35 2018

@author: wcy
"""
import numpy as np
import scipy.misc
import cv2
import scipy.io
import os, sys, argparse
import time
from os.path import join, splitext, split, isfile
parser = argparse.ArgumentParser(description='Forward all testing images.')
parser.add_argument('--model', type=str, default='../snapshot/casia/iris_iter_30000.caffemodel') 
parser.add_argument('--net', type=str, default='../model/casia/deploy_bottom_up.pt')
parser.add_argument('--gpu', type=int, default=3)
args = parser.parse_args()
caffe_root = './caffe/'
sys.path.insert(0, caffe_root + 'python')
import caffe
EPSILON = 1e-8

def forward(data):
  assert data.ndim == 3
  data -= np.array((104.00698793,116.66876762,122.67891434))
  data = data.transpose((2, 0, 1))
  net.blobs['data'].reshape(1, *data.shape)
  net.blobs['data'].data[...] = data
  return net.forward()
  
def load_image(path, width=0,height=0, pad=True):
    """
    Load image from a given path and pad it on the sides, so that eash side is divisible by 32 (newtwork requirement)
    
    if pad = True:
        returns image as numpy.array, tuple with padding in pixels as(x_min_pad, y_min_pad, x_max_pad, y_max_pad)
    else:
        returns image as numpy.array
    """
    img = cv2.imread(str(path)).astype(np.float32)
    if img.ndim == 2:
       img = img[:, :, np.newaxis]
       img = np.repeat(img, 3, 2)
    
    if not pad:
        return img
    
    ori_height, ori_width, _ = img.shape
    
    if width==0:   #ÈÄâÊã©Ë∑ùÁ¶ªÊ†áÂáÜÊúÄËøëÁöÑÂ§ßÂ∞è
        k = int(np.ceil((ori_width+31)/32.0))
        width = 32*k-31
    if height==0:
        k = int(np.ceil((ori_height+31)/32.0))
        height = 32*k-31
    
    pad_height = max(height - ori_height, 0);
    pad_width  = max(width - ori_width, 0);
    
    print("width:{},height:{}".format(width,  height ))
    
    img = cv2.copyMakeBorder(img, 0, pad_height, 0, pad_width, cv2.BORDER_REFLECT_101)

    return img, (pad_height, pad_width)  
  
def crop_image(img, pads):
    """
    img: numpy array of the shape (height, width)
    pads: (pad_height, pad_width) 
    
    @return padded image
    """
    (pad_height, pad_width)  = pads
    height, width = img.shape[-2:] 
    
    if len(img.shape) == 2:
        return img[0:height - pad_height, 0:width - pad_width]
    elif len(img.shape)==3:
        return img[:,0:height - pad_height, 0:width - pad_width]
    else:
        return img
    
def create_labels(map,threshold=0.5): #h*w
    labels=(map&gt;=threshold).astype(np.float32)
    return labels


assert isfile(args.model) and isfile(args.net), 'file not exists'
USE_GPU = True
if USE_GPU:
   caffe.set_device(args.gpu)
   caffe.set_mode_gpu()
else:
   caffe.set_mode_cpu()

net = caffe.Net(args.net, args.model, caffe.TEST)
test_dir = '/data3/caiyong.wang/data/IrisLocSeg/CASIA-distance/test/image/' # test images directory
save_mask_dir = join('./test/casia_distance/', splitext(split(args.model)[1])[0],'mask/') # directory to save results
if not os.path.exists(save_mask_dir):  
    os.makedirs(save_mask_dir)
save_pupil_dir = join('./test/casia_distance/', splitext(split(args.model)[1])[0],'pupil/') # directory to save results
if not os.path.exists(save_pupil_dir):
    os.makedirs(save_pupil_dir) 
save_iris_dir = join('./test/casia_distance/', splitext(split(args.model)[1])[0],'iris/') # directory to save results
if not os.path.exists(save_iris_dir):
    os.makedirs(save_iris_dir)              
    
imgs = [i for i in os.listdir(test_dir) if '.JPEG' in i]
nimgs = len(imgs)
print "totally "+str(nimgs)+"images"
start = time.time()
for i in range(nimgs):
  img_path = join(test_dir, imgs[i])
  img, pads = load_image(img_path,0,0, pad=True)
  fn, ext = splitext(imgs[i])
	
  forward(img)
  
  mask_out1 = crop_image(net.blobs['Sigmoid_fuse_mask'].data[0][0,:,:], pads)
  

  scipy.misc.imsave(join(save_mask_dir, fn+'.png'),mask_out1)
  
  iris_result = crop_image(net.blobs['Sigmoid_fuse_iris'].data[0][0,:,:], pads)
  
  scipy.misc.imsave(join(save_iris_dir, fn+'.png'),iris_result)
  
  pupil_result = crop_image(net.blobs["Sigmoid_fuse_pupil"].data[0][0,:,:], pads)
  
  scipy.misc.imsave(join(save_pupil_dir, fn+'.png'),pupil_result)
  
  
  print "Saving to '" + join(save_mask_dir, imgs[i][0:-4]) + "', Processing %d of %d..."%(i + 1, nimgs) 
end = time.time()
avg_time = (end-start)/nimgs
print("average time is %f seconds"%avg_time)
</file><file name="train_direct_casia.py">from __future__ import division
import numpy as np
import sys, os, argparse
from os.path import isfile, join, isdir
sys.path.insert(0, './caffe/python')
import caffe
parser = argparse.ArgumentParser(description='Training dds nets.')
parser.add_argument('--gpu', type=int, help='gpu ID', default=0)
parser.add_argument('--solver', type=str, help='solver', default='./model/casia/solver_bottom_up.prototxt')
parser.add_argument('--weights', type=str, help='base model', default='./snapshot/VGG_ILSVRC_16_layers.caffemodel')
args = parser.parse_args()
assert isfile(args.weights) and isfile(args.solver)

caffe.set_mode_gpu()
caffe.set_device(args.gpu)

solver = caffe.SGDSolver(args.solver)
solver.net.copy_from(args.weights)
solver.solve()

</file><file name="train_direct_nice.py">from __future__ import division
import numpy as np
import sys, os, argparse
from os.path import isfile, join, isdir
sys.path.insert(0, './caffe/python')
import caffe
parser = argparse.ArgumentParser(description='Training dds nets.')
parser.add_argument('--gpu', type=int, help='gpu ID', default=0)
parser.add_argument('--solver', type=str, help='solver', default='./model/nice/solver_bottom_up.prototxt')
parser.add_argument('--weights', type=str, help='base model', default='./snapshot/VGG_ILSVRC_16_layers.caffemodel')
args = parser.parse_args()
assert isfile(args.weights) and isfile(args.solver)

caffe.set_mode_gpu()
caffe.set_device(args.gpu)

solver = caffe.SGDSolver(args.solver)
solver.net.copy_from(args.weights)
solver.solve()

</file><file name="train_direct_miche.py">from __future__ import division
import numpy as np
import sys, os, argparse
from os.path import isfile, join, isdir
sys.path.insert(0, './caffe/python')
import caffe
parser = argparse.ArgumentParser(description='Training dds nets.')
parser.add_argument('--gpu', type=int, help='gpu ID', default=0)
parser.add_argument('--solver', type=str, help='solver', default='./model/miche/solver_bottom_up.prototxt')
parser.add_argument('--weights', type=str, help='base model', default='./snapshot/VGG_ILSVRC_16_layers.caffemodel')
args = parser.parse_args()
assert isfile(args.weights) and isfile(args.solver)

caffe.set_mode_gpu()
caffe.set_device(args.gpu)

solver = caffe.SGDSolver(args.solver)
solver.net.copy_from(args.weights)
solver.solve()

</file></files>